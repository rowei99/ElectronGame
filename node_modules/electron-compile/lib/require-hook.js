'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = registerRequireExtension;

var _mimeTypes = require('@paulcbetts/mime-types');

var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let HMR = false;

const d = require('debug')('electron-compile:require-hook');
let electron = null;

if (process.type === 'renderer') {
  window.__hot = [];
  electron = require('electron');
  HMR = electron.remote.getGlobal('__electron_compile_hmr_enabled__');

  if (HMR) {
    electron.ipcRenderer.on('__electron-compile__HMR', () => {
      d("Got HMR signal!");

      // Reset the module cache
      let cache = require('module')._cache;
      let toEject = Object.keys(cache).filter(x => x && !x.match(/[\\\/](node_modules|.*\.asar)[\\\/]/i));
      toEject.forEach(x => {
        d(`Removing node module entry for ${x}`);
        delete cache[x];
      });

      window.__hot.forEach(fn => fn());
    });
  }
}

/**
 * Initializes the node.js hook that allows us to intercept files loaded by
 * node.js and rewrite them. This method along with {@link initializeProtocolHook}
 * are the top-level methods that electron-compile actually uses to intercept
 * code that Electron loads.
 *
 * @param  {CompilerHost} compilerHost  The compiler host to use for compilation.
 */
function registerRequireExtension(compilerHost) {
  if (HMR) {
    try {
      require('module').prototype.hot = {
        accept: cb => window.__hot.push(cb)
      };

      require.main.require('react-hot-loader/patch');
    } catch (e) {
      console.error(`Couldn't require react-hot-loader/patch, you need to add react-hot-loader@3 as a dependency! ${e.message}`);
    }
  }

  Object.keys(compilerHost.compilersByMimeType).forEach(mimeType => {
    let ext = _mimeTypes2.default.extension(mimeType);

    require.extensions[`.${ext}`] = (module, filename) => {
      var _compilerHost$compile = compilerHost.compileSync(filename);

      let code = _compilerHost$compile.code;


      if (code === null) {
        console.error(`null code returned for "${filename}".  Please raise an issue on 'electron-compile' with the contents of this file.`);
      }

      module._compile(code, filename);
    };
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXF1aXJlLWhvb2suanMiXSwibmFtZXMiOlsicmVnaXN0ZXJSZXF1aXJlRXh0ZW5zaW9uIiwiSE1SIiwiZCIsInJlcXVpcmUiLCJlbGVjdHJvbiIsInByb2Nlc3MiLCJ0eXBlIiwid2luZG93IiwiX19ob3QiLCJyZW1vdGUiLCJnZXRHbG9iYWwiLCJpcGNSZW5kZXJlciIsIm9uIiwiY2FjaGUiLCJfY2FjaGUiLCJ0b0VqZWN0IiwiT2JqZWN0Iiwia2V5cyIsImZpbHRlciIsIngiLCJtYXRjaCIsImZvckVhY2giLCJmbiIsImNvbXBpbGVySG9zdCIsInByb3RvdHlwZSIsImhvdCIsImFjY2VwdCIsImNiIiwicHVzaCIsIm1haW4iLCJlIiwiY29uc29sZSIsImVycm9yIiwibWVzc2FnZSIsImNvbXBpbGVyc0J5TWltZVR5cGUiLCJtaW1lVHlwZSIsImV4dCIsImV4dGVuc2lvbiIsImV4dGVuc2lvbnMiLCJtb2R1bGUiLCJmaWxlbmFtZSIsImNvbXBpbGVTeW5jIiwiY29kZSIsIl9jb21waWxlIl0sIm1hcHBpbmdzIjoiOzs7OztrQkFxQ3dCQSx3Qjs7QUFyQ3hCOzs7Ozs7QUFFQSxJQUFJQyxNQUFNLEtBQVY7O0FBRUEsTUFBTUMsSUFBSUMsUUFBUSxPQUFSLEVBQWlCLCtCQUFqQixDQUFWO0FBQ0EsSUFBSUMsV0FBVyxJQUFmOztBQUVBLElBQUlDLFFBQVFDLElBQVIsS0FBaUIsVUFBckIsRUFBaUM7QUFDL0JDLFNBQU9DLEtBQVAsR0FBZSxFQUFmO0FBQ0FKLGFBQVdELFFBQVEsVUFBUixDQUFYO0FBQ0FGLFFBQU1HLFNBQVNLLE1BQVQsQ0FBZ0JDLFNBQWhCLENBQTBCLGtDQUExQixDQUFOOztBQUVBLE1BQUlULEdBQUosRUFBUztBQUNQRyxhQUFTTyxXQUFULENBQXFCQyxFQUFyQixDQUF3Qix5QkFBeEIsRUFBbUQsTUFBTTtBQUN2RFYsUUFBRSxpQkFBRjs7QUFFQTtBQUNBLFVBQUlXLFFBQVFWLFFBQVEsUUFBUixFQUFrQlcsTUFBOUI7QUFDQSxVQUFJQyxVQUFVQyxPQUFPQyxJQUFQLENBQVlKLEtBQVosRUFBbUJLLE1BQW5CLENBQTBCQyxLQUFLQSxLQUFLLENBQUNBLEVBQUVDLEtBQUYsQ0FBUSxzQ0FBUixDQUFyQyxDQUFkO0FBQ0FMLGNBQVFNLE9BQVIsQ0FBZ0JGLEtBQUs7QUFDbkJqQixVQUFHLGtDQUFpQ2lCLENBQUUsRUFBdEM7QUFDQSxlQUFPTixNQUFNTSxDQUFOLENBQVA7QUFDRCxPQUhEOztBQUtBWixhQUFPQyxLQUFQLENBQWFhLE9BQWIsQ0FBcUJDLE1BQU1BLElBQTNCO0FBQ0QsS0FaRDtBQWFEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O0FBUWUsU0FBU3RCLHdCQUFULENBQWtDdUIsWUFBbEMsRUFBZ0Q7QUFDN0QsTUFBSXRCLEdBQUosRUFBUztBQUNQLFFBQUk7QUFDRkUsY0FBUSxRQUFSLEVBQWtCcUIsU0FBbEIsQ0FBNEJDLEdBQTVCLEdBQWtDO0FBQ2hDQyxnQkFBU0MsRUFBRCxJQUFRcEIsT0FBT0MsS0FBUCxDQUFhb0IsSUFBYixDQUFrQkQsRUFBbEI7QUFEZ0IsT0FBbEM7O0FBSUF4QixjQUFRMEIsSUFBUixDQUFhMUIsT0FBYixDQUFxQix3QkFBckI7QUFDRCxLQU5ELENBTUUsT0FBTzJCLENBQVAsRUFBVTtBQUNWQyxjQUFRQyxLQUFSLENBQWUsZ0dBQStGRixFQUFFRyxPQUFRLEVBQXhIO0FBQ0Q7QUFDRjs7QUFFRGpCLFNBQU9DLElBQVAsQ0FBWU0sYUFBYVcsbUJBQXpCLEVBQThDYixPQUE5QyxDQUF1RGMsUUFBRCxJQUFjO0FBQ2xFLFFBQUlDLE1BQU0sb0JBQVVDLFNBQVYsQ0FBb0JGLFFBQXBCLENBQVY7O0FBRUFoQyxZQUFRbUMsVUFBUixDQUFvQixJQUFHRixHQUFJLEVBQTNCLElBQWdDLENBQUNHLE1BQUQsRUFBU0MsUUFBVCxLQUFzQjtBQUFBLGtDQUN2Q2pCLGFBQWFrQixXQUFiLENBQXlCRCxRQUF6QixDQUR1Qzs7QUFBQSxVQUMvQ0UsSUFEK0MseUJBQy9DQSxJQUQrQzs7O0FBR3BELFVBQUlBLFNBQVMsSUFBYixFQUFtQjtBQUNqQlgsZ0JBQVFDLEtBQVIsQ0FBZSwyQkFBMEJRLFFBQVMsaUZBQWxEO0FBQ0Q7O0FBRURELGFBQU9JLFFBQVAsQ0FBZ0JELElBQWhCLEVBQXNCRixRQUF0QjtBQUNELEtBUkQ7QUFTRCxHQVpEO0FBYUQiLCJmaWxlIjoicmVxdWlyZS1ob29rLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1pbWVUeXBlcyBmcm9tICdAcGF1bGNiZXR0cy9taW1lLXR5cGVzJztcclxuXHJcbmxldCBITVIgPSBmYWxzZTtcclxuXHJcbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbGVjdHJvbi1jb21waWxlOnJlcXVpcmUtaG9vaycpO1xyXG5sZXQgZWxlY3Ryb24gPSBudWxsO1xyXG5cclxuaWYgKHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xyXG4gIHdpbmRvdy5fX2hvdCA9IFtdO1xyXG4gIGVsZWN0cm9uID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcclxuICBITVIgPSBlbGVjdHJvbi5yZW1vdGUuZ2V0R2xvYmFsKCdfX2VsZWN0cm9uX2NvbXBpbGVfaG1yX2VuYWJsZWRfXycpO1xyXG5cclxuICBpZiAoSE1SKSB7XHJcbiAgICBlbGVjdHJvbi5pcGNSZW5kZXJlci5vbignX19lbGVjdHJvbi1jb21waWxlX19ITVInLCAoKSA9PiB7XHJcbiAgICAgIGQoXCJHb3QgSE1SIHNpZ25hbCFcIik7XHJcblxyXG4gICAgICAvLyBSZXNldCB0aGUgbW9kdWxlIGNhY2hlXHJcbiAgICAgIGxldCBjYWNoZSA9IHJlcXVpcmUoJ21vZHVsZScpLl9jYWNoZTtcclxuICAgICAgbGV0IHRvRWplY3QgPSBPYmplY3Qua2V5cyhjYWNoZSkuZmlsdGVyKHggPT4geCAmJiAheC5tYXRjaCgvW1xcXFxcXC9dKG5vZGVfbW9kdWxlc3wuKlxcLmFzYXIpW1xcXFxcXC9dL2kpKTtcclxuICAgICAgdG9FamVjdC5mb3JFYWNoKHggPT4ge1xyXG4gICAgICAgIGQoYFJlbW92aW5nIG5vZGUgbW9kdWxlIGVudHJ5IGZvciAke3h9YCk7XHJcbiAgICAgICAgZGVsZXRlIGNhY2hlW3hdO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHdpbmRvdy5fX2hvdC5mb3JFYWNoKGZuID0+IGZuKCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgdGhlIG5vZGUuanMgaG9vayB0aGF0IGFsbG93cyB1cyB0byBpbnRlcmNlcHQgZmlsZXMgbG9hZGVkIGJ5XHJcbiAqIG5vZGUuanMgYW5kIHJld3JpdGUgdGhlbS4gVGhpcyBtZXRob2QgYWxvbmcgd2l0aCB7QGxpbmsgaW5pdGlhbGl6ZVByb3RvY29sSG9va31cclxuICogYXJlIHRoZSB0b3AtbGV2ZWwgbWV0aG9kcyB0aGF0IGVsZWN0cm9uLWNvbXBpbGUgYWN0dWFsbHkgdXNlcyB0byBpbnRlcmNlcHRcclxuICogY29kZSB0aGF0IEVsZWN0cm9uIGxvYWRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtDb21waWxlckhvc3R9IGNvbXBpbGVySG9zdCAgVGhlIGNvbXBpbGVyIGhvc3QgdG8gdXNlIGZvciBjb21waWxhdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlZ2lzdGVyUmVxdWlyZUV4dGVuc2lvbihjb21waWxlckhvc3QpIHtcclxuICBpZiAoSE1SKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXF1aXJlKCdtb2R1bGUnKS5wcm90b3R5cGUuaG90ID0ge1xyXG4gICAgICAgIGFjY2VwdDogKGNiKSA9PiB3aW5kb3cuX19ob3QucHVzaChjYilcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJlcXVpcmUubWFpbi5yZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyL3BhdGNoJyk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkbid0IHJlcXVpcmUgcmVhY3QtaG90LWxvYWRlci9wYXRjaCwgeW91IG5lZWQgdG8gYWRkIHJlYWN0LWhvdC1sb2FkZXJAMyBhcyBhIGRlcGVuZGVuY3khICR7ZS5tZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgT2JqZWN0LmtleXMoY29tcGlsZXJIb3N0LmNvbXBpbGVyc0J5TWltZVR5cGUpLmZvckVhY2goKG1pbWVUeXBlKSA9PiB7XHJcbiAgICBsZXQgZXh0ID0gbWltZVR5cGVzLmV4dGVuc2lvbihtaW1lVHlwZSk7XHJcblxyXG4gICAgcmVxdWlyZS5leHRlbnNpb25zW2AuJHtleHR9YF0gPSAobW9kdWxlLCBmaWxlbmFtZSkgPT4ge1xyXG4gICAgICBsZXQge2NvZGV9ID0gY29tcGlsZXJIb3N0LmNvbXBpbGVTeW5jKGZpbGVuYW1lKTtcclxuXHJcbiAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgbnVsbCBjb2RlIHJldHVybmVkIGZvciBcIiR7ZmlsZW5hbWV9XCIuICBQbGVhc2UgcmFpc2UgYW4gaXNzdWUgb24gJ2VsZWN0cm9uLWNvbXBpbGUnIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoaXMgZmlsZS5gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbW9kdWxlLl9jb21waWxlKGNvZGUsIGZpbGVuYW1lKTtcclxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuIl19