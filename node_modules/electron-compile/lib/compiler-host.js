'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _mimeTypes = require('@paulcbetts/mime-types');

var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _promise = require('./promise');

var _forAllFiles = require('./for-all-files');

var _compileCache = require('./compile-cache');

var _compileCache2 = _interopRequireDefault(_compileCache);

var _fileChangeCache = require('./file-change-cache');

var _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);

var _readOnlyCompiler = require('./read-only-compiler');

var _readOnlyCompiler2 = _interopRequireDefault(_readOnlyCompiler);

var _browserSignal = require('./browser-signal');

require('rxjs/add/operator/map');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const d = require('debug')('electron-compile:compiler-host');

require('./rig-mime-types').init();

// This isn't even my
const finalForms = {
  'text/javascript': true,
  'application/javascript': true,
  'text/html': true,
  'text/css': true,
  'image/svg+xml': true,
  'application/json': true
};

/**
 * This class is the top-level class that encapsulates all of the logic of
 * compiling and caching application code. If you're looking for a "Main class",
 * this is it.
 *
 * This class can be created directly but it is usually created via the methods
 * in config-parser, which will among other things, set up the compiler options
 * given a project root.
 *
 * CompilerHost is also the top-level class that knows how to serialize all of the
 * information necessary to recreate itself, either as a development host (i.e.
 * will allow cache misses and actual compilation), or as a read-only version of
 * itself for production.
 */
class CompilerHost {
  /**
   * Creates an instance of CompilerHost. You probably want to use the methods
   * in config-parser for development, or {@link createReadonlyFromConfiguration}
   * for production instead.
   *
   * @param  {string} rootCacheDir  The root directory to use for the cache
   *
   * @param  {Object} compilers  an Object whose keys are input MIME types and
   *                             whose values are instances of CompilerBase. Create
   *                             this via the {@link createCompilers} method in
   *                             config-parser.
   *
   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is
   *                                             optionally pre-loaded.
   *
   * @param  {boolean} readOnlyMode  If True, cache misses will fail and
   *                                 compilation will not be attempted.
   *
   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
   *                                         which doesn't have a matching compiler,
   *                                         this compiler will be used instead. If
   *                                         null, will fail compilation. A good
   *                                         alternate fallback is the compiler for
   *                                         'text/plain', which is guaranteed to be
   *                                         present.
   *
   * @param {string} sourceMapPath (optional) The directory to store sourcemap separately
   *                               if compiler option enabled to emit.
   *                               Default to cachePath if not specified.
   */
  constructor(rootCacheDir, compilers, fileChangeCache, readOnlyMode) {
    let fallbackCompiler = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    let sourceMapPath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

    let compilersByMimeType = Object.assign({}, compilers);
    Object.assign(this, { rootCacheDir, compilersByMimeType, fileChangeCache, readOnlyMode, fallbackCompiler });
    this.appRoot = this.fileChangeCache.appRoot;

    this.cachesForCompilers = Object.keys(compilersByMimeType).reduce((acc, x) => {
      let compiler = compilersByMimeType[x];
      if (acc.has(compiler)) return acc;

      acc.set(compiler, _compileCache2.default.createFromCompiler(rootCacheDir, compiler, fileChangeCache, readOnlyMode, sourceMapPath));
      return acc;
    }, new Map());
  }

  /**
   * Creates a production-mode CompilerHost from the previously saved
   * configuration
   *
   * @param  {string} rootCacheDir  The root directory to use for the cache. This
   *                                cache must have cache information saved via
   *                                {@link saveConfiguration}
   *
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   *
   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
   *                                         which doesn't have a matching compiler,
   *                                         this compiler will be used instead. If
   *                                         null, will fail compilation. A good
   *                                         alternate fallback is the compiler for
   *                                         'text/plain', which is guaranteed to be
   *                                         present.
   *
   * @return {Promise<CompilerHost>}  A read-only CompilerHost
   */
  static createReadonlyFromConfiguration(rootCacheDir, appRoot) {
    let fallbackCompiler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return _asyncToGenerator(function* () {
      let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
      let buf = yield _promise.pfs.readFile(target);
      let info = JSON.parse((yield _promise.pzlib.gunzip(buf)));

      let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);

      let compilers = Object.keys(info.compilers).reduce(function (acc, x) {
        let cur = info.compilers[x];
        acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);

        return acc;
      }, {});

      return new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler);
    })();
  }

  /**
   * Creates a development-mode CompilerHost from the previously saved
   * configuration.
   *
   * @param  {string} rootCacheDir  The root directory to use for the cache. This
   *                                cache must have cache information saved via
   *                                {@link saveConfiguration}
   *
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   *
   * @param  {Object} compilersByMimeType  an Object whose keys are input MIME
   *                                       types and whose values are instances
   *                                       of CompilerBase. Create this via the
   *                                       {@link createCompilers} method in
   *                                       config-parser.
   *
   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
   *                                         which doesn't have a matching compiler,
   *                                         this compiler will be used instead. If
   *                                         null, will fail compilation. A good
   *                                         alternate fallback is the compiler for
   *                                         'text/plain', which is guaranteed to be
   *                                         present.
   *
   * @return {Promise<CompilerHost>}  A read-only CompilerHost
   */
  static createFromConfiguration(rootCacheDir, appRoot, compilersByMimeType) {
    let fallbackCompiler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    return _asyncToGenerator(function* () {
      let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
      let buf = yield _promise.pfs.readFile(target);
      let info = JSON.parse((yield _promise.pzlib.gunzip(buf)));

      let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);

      Object.keys(info.compilers).forEach(function (x) {
        let cur = info.compilers[x];
        compilersByMimeType[x].compilerOptions = cur.compilerOptions;
      });

      return new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler);
    })();
  }

  /**
   * Saves the current compiler configuration to a file that
   * {@link createReadonlyFromConfiguration} can use to recreate the current
   * compiler environment
   *
   * @return {Promise}  Completion
   */
  saveConfiguration() {
    var _this = this;

    return _asyncToGenerator(function* () {
      let serializedCompilerOpts = Object.keys(_this.compilersByMimeType).reduce(function (acc, x) {
        let compiler = _this.compilersByMimeType[x];
        let Klass = Object.getPrototypeOf(compiler).constructor;

        let val = {
          name: Klass.name,
          inputMimeTypes: Klass.getInputMimeTypes(),
          compilerOptions: compiler.compilerOptions,
          compilerVersion: compiler.getCompilerVersion()
        };

        acc[x] = val;
        return acc;
      }, {});

      let info = {
        fileChangeCache: _this.fileChangeCache.getSavedData(),
        compilers: serializedCompilerOpts
      };

      let target = _path2.default.join(_this.rootCacheDir, 'compiler-info.json.gz');
      let buf = yield _promise.pzlib.gzip(new Buffer(JSON.stringify(info)));
      yield _promise.pfs.writeFile(target, buf);
    })();
  }

  /**
   * Compiles a file and returns the compiled result.
   *
   * @param  {string} filePath  The path to the file to compile
   *
   * @return {Promise<object>}  An Object with the compiled result
   *
   * @property {Object} hashInfo  The hash information returned from getHashForPath
   * @property {string} code  The source code if the file was a text file
   * @property {Buffer} binaryData  The file if it was a binary file
   * @property {string} mimeType  The MIME type saved in the cache.
   * @property {string[]} dependentFiles  The dependent files returned from
   *                                      compiling the file, if any.
   */
  compile(filePath) {
    return this.readOnlyMode ? this.compileReadOnly(filePath) : this.fullCompile(filePath);
  }

  /**
   * Handles compilation in read-only mode
   *
   * @private
   */
  compileReadOnly(filePath) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      // We guarantee that node_modules are always shipped directly
      let type = _mimeTypes2.default.lookup(filePath);
      if (_fileChangeCache2.default.isInNodeModules(filePath)) {
        return {
          mimeType: type || 'application/javascript',
          code: yield _promise.pfs.readFile(filePath, 'utf8')
        };
      }

      let hashInfo = yield _this2.fileChangeCache.getHashForPath(filePath);

      // NB: Here, we're basically only using the compiler here to find
      // the appropriate CompileCache
      let compiler = CompilerHost.shouldPassthrough(hashInfo) ? _this2.getPassthroughCompiler() : _this2.compilersByMimeType[type || '__lolnothere'];

      // NB: We don't put this into shouldPassthrough because Inline HTML
      // compiler is technically of type finalForms (i.e. a browser can
      // natively handle this content), yet its compiler is
      // InlineHtmlCompiler. However, we still want to catch standard CSS files
      // which will be processed by PassthroughCompiler.
      if (finalForms[type] && !compiler) {
        compiler = _this2.getPassthroughCompiler();
      }

      if (!compiler) {
        compiler = _this2.fallbackCompiler;

        var _ref = yield compiler.get(filePath);

        let code = _ref.code,
            binaryData = _ref.binaryData,
            mimeType = _ref.mimeType;

        return { code: code || binaryData, mimeType };
      }

      let cache = _this2.cachesForCompilers.get(compiler);

      var _ref2 = yield cache.get(filePath);

      let code = _ref2.code,
          binaryData = _ref2.binaryData,
          mimeType = _ref2.mimeType;


      code = code || binaryData;
      if (!code || !mimeType) {
        throw new Error(`Asked to compile ${filePath} in production, is this file not precompiled?`);
      }

      return { code, mimeType };
    })();
  }

  /**
   * Handles compilation in read-write mode
   *
   * @private
   */
  fullCompile(filePath) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      d(`Compiling ${filePath}`);

      let hashInfo = yield _this3.fileChangeCache.getHashForPath(filePath);
      let type = _mimeTypes2.default.lookup(filePath);

      (0, _browserSignal.send)('electron-compile-compiled-file', { filePath, mimeType: type });

      if (hashInfo.isInNodeModules) {
        let code = hashInfo.sourceCode || (yield _promise.pfs.readFile(filePath, 'utf8'));
        code = yield CompilerHost.fixNodeModulesSourceMapping(code, filePath, _this3.fileChangeCache.appRoot);
        return { code, mimeType: type };
      }

      let compiler = CompilerHost.shouldPassthrough(hashInfo) ? _this3.getPassthroughCompiler() : _this3.compilersByMimeType[type || '__lolnothere'];

      if (!compiler) {
        d(`Falling back to passthrough compiler for ${filePath}`);
        compiler = _this3.fallbackCompiler;
      }

      if (!compiler) {
        throw new Error(`Couldn't find a compiler for ${filePath}`);
      }

      let cache = _this3.cachesForCompilers.get(compiler);
      return yield cache.getOrFetch(filePath, function (filePath, hashInfo) {
        return _this3.compileUncached(filePath, hashInfo, compiler);
      });
    })();
  }

  /**
   * Handles invoking compilers independent of caching
   *
   * @private
   */
  compileUncached(filePath, hashInfo, compiler) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      let inputMimeType = _mimeTypes2.default.lookup(filePath);

      if (hashInfo.isFileBinary) {
        return {
          binaryData: hashInfo.binaryData || (yield _promise.pfs.readFile(filePath)),
          mimeType: inputMimeType,
          dependentFiles: []
        };
      }

      let ctx = {};
      let code = hashInfo.sourceCode || (yield _promise.pfs.readFile(filePath, 'utf8'));

      if (!(yield compiler.shouldCompileFile(code, ctx))) {
        d(`Compiler returned false for shouldCompileFile: ${filePath}`);
        return { code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] };
      }

      let dependentFiles = yield compiler.determineDependentFiles(code, filePath, ctx);

      d(`Using compiler options: ${JSON.stringify(compiler.compilerOptions)}`);
      let result = yield compiler.compile(code, filePath, ctx);

      let shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';

      let isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);

      if (finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough) {
        // Got something we can use in-browser, let's return it
        return Object.assign(result, { dependentFiles });
      } else {
        d(`Recursively compiling result of ${filePath} with non-final MIME type ${result.mimeType}, input was ${inputMimeType}`);

        hashInfo = Object.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);
        compiler = _this4.compilersByMimeType[result.mimeType || '__lolnothere'];

        if (!compiler) {
          d(`Recursive compile failed - intermediate result: ${JSON.stringify(result)}`);

          throw new Error(`Compiling ${filePath} resulted in a MIME type of ${result.mimeType}, which we don't know how to handle`);
        }

        return yield _this4.compileUncached(`${filePath}.${_mimeTypes2.default.extension(result.mimeType || 'txt')}`, hashInfo, compiler);
      }
    })();
  }

  /**
   * Pre-caches an entire directory of files recursively. Usually used for
   * building custom compiler tooling.
   *
   * @param  {string} rootDirectory  The top-level directory to compile
   *
   * @param  {Function} shouldCompile (optional)  A Function which allows the
   *                                  caller to disable compiling certain files.
   *                                  It takes a fully-qualified path to a file,
   *                                  and should return a Boolean.
   *
   * @return {Promise}  Completion.
   */
  compileAll(rootDirectory) {
    var _this5 = this;

    let shouldCompile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return _asyncToGenerator(function* () {
      let should = shouldCompile || function () {
        return true;
      };

      yield (0, _forAllFiles.forAllFiles)(rootDirectory, function (f) {
        if (!should(f)) return;

        d(`Compiling ${f}`);
        return _this5.compile(f, _this5.compilersByMimeType);
      });
    })();
  }

  listenToCompileEvents() {
    return (0, _browserSignal.listen)('electron-compile-compiled-file').map((_ref3) => {
      var _ref4 = _slicedToArray(_ref3, 1);

      let x = _ref4[0];
      return x;
    });
  }

  /*
   * Sync Methods
   */

  compileSync(filePath) {
    return this.readOnlyMode ? this.compileReadOnlySync(filePath) : this.fullCompileSync(filePath);
  }

  static createReadonlyFromConfigurationSync(rootCacheDir, appRoot) {
    let fallbackCompiler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
    let buf = _fs2.default.readFileSync(target);
    let info = JSON.parse(_zlib2.default.gunzipSync(buf));

    let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);

    let compilers = Object.keys(info.compilers).reduce((acc, x) => {
      let cur = info.compilers[x];
      acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);

      return acc;
    }, {});

    return new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler);
  }

  static createFromConfigurationSync(rootCacheDir, appRoot, compilersByMimeType) {
    let fallbackCompiler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
    let buf = _fs2.default.readFileSync(target);
    let info = JSON.parse(_zlib2.default.gunzipSync(buf));

    let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);

    Object.keys(info.compilers).forEach(x => {
      let cur = info.compilers[x];
      compilersByMimeType[x].compilerOptions = cur.compilerOptions;
    });

    return new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler);
  }

  saveConfigurationSync() {
    let serializedCompilerOpts = Object.keys(this.compilersByMimeType).reduce((acc, x) => {
      let compiler = this.compilersByMimeType[x];
      let Klass = Object.getPrototypeOf(compiler).constructor;

      let val = {
        name: Klass.name,
        inputMimeTypes: Klass.getInputMimeTypes(),
        compilerOptions: compiler.compilerOptions,
        compilerVersion: compiler.getCompilerVersion()
      };

      acc[x] = val;
      return acc;
    }, {});

    let info = {
      fileChangeCache: this.fileChangeCache.getSavedData(),
      compilers: serializedCompilerOpts
    };

    let target = _path2.default.join(this.rootCacheDir, 'compiler-info.json.gz');
    let buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify(info)));
    _fs2.default.writeFileSync(target, buf);
  }

  compileReadOnlySync(filePath) {
    // We guarantee that node_modules are always shipped directly
    let type = _mimeTypes2.default.lookup(filePath);
    if (_fileChangeCache2.default.isInNodeModules(filePath)) {
      return {
        mimeType: type || 'application/javascript',
        code: _fs2.default.readFileSync(filePath, 'utf8')
      };
    }

    let hashInfo = this.fileChangeCache.getHashForPathSync(filePath);

    // We guarantee that node_modules are always shipped directly
    if (hashInfo.isInNodeModules) {
      return {
        mimeType: type,
        code: hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8')
      };
    }

    // NB: Here, we're basically only using the compiler here to find
    // the appropriate CompileCache
    let compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

    // NB: We don't put this into shouldPassthrough because Inline HTML
    // compiler is technically of type finalForms (i.e. a browser can
    // natively handle this content), yet its compiler is
    // InlineHtmlCompiler. However, we still want to catch standard CSS files
    // which will be processed by PassthroughCompiler.
    if (finalForms[type] && !compiler) {
      compiler = this.getPassthroughCompiler();
    }

    if (!compiler) {
      compiler = this.fallbackCompiler;

      var _compiler$getSync = compiler.getSync(filePath);

      let code = _compiler$getSync.code,
          binaryData = _compiler$getSync.binaryData,
          mimeType = _compiler$getSync.mimeType;

      return { code: code || binaryData, mimeType };
    }

    let cache = this.cachesForCompilers.get(compiler);

    var _cache$getSync = cache.getSync(filePath);

    let code = _cache$getSync.code,
        binaryData = _cache$getSync.binaryData,
        mimeType = _cache$getSync.mimeType;


    code = code || binaryData;
    if (!code || !mimeType) {
      throw new Error(`Asked to compile ${filePath} in production, is this file not precompiled?`);
    }

    return { code, mimeType };
  }

  fullCompileSync(filePath) {
    d(`Compiling ${filePath}`);

    let hashInfo = this.fileChangeCache.getHashForPathSync(filePath);
    let type = _mimeTypes2.default.lookup(filePath);

    (0, _browserSignal.send)('electron-compile-compiled-file', { filePath, mimeType: type });

    if (hashInfo.isInNodeModules) {
      let code = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');
      code = CompilerHost.fixNodeModulesSourceMappingSync(code, filePath, this.fileChangeCache.appRoot);
      return { code, mimeType: type };
    }

    let compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

    if (!compiler) {
      d(`Falling back to passthrough compiler for ${filePath}`);
      compiler = this.fallbackCompiler;
    }

    if (!compiler) {
      throw new Error(`Couldn't find a compiler for ${filePath}`);
    }

    let cache = this.cachesForCompilers.get(compiler);
    return cache.getOrFetchSync(filePath, (filePath, hashInfo) => this.compileUncachedSync(filePath, hashInfo, compiler));
  }

  compileUncachedSync(filePath, hashInfo, compiler) {
    let inputMimeType = _mimeTypes2.default.lookup(filePath);

    if (hashInfo.isFileBinary) {
      return {
        binaryData: hashInfo.binaryData || _fs2.default.readFileSync(filePath),
        mimeType: inputMimeType,
        dependentFiles: []
      };
    }

    let ctx = {};
    let code = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');

    if (!compiler.shouldCompileFileSync(code, ctx)) {
      d(`Compiler returned false for shouldCompileFile: ${filePath}`);
      return { code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] };
    }

    let dependentFiles = compiler.determineDependentFilesSync(code, filePath, ctx);

    let result = compiler.compileSync(code, filePath, ctx);

    let shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';

    let isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);

    if (finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough) {
      // Got something we can use in-browser, let's return it
      return Object.assign(result, { dependentFiles });
    } else {
      d(`Recursively compiling result of ${filePath} with non-final MIME type ${result.mimeType}, input was ${inputMimeType}`);

      hashInfo = Object.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);
      compiler = this.compilersByMimeType[result.mimeType || '__lolnothere'];

      if (!compiler) {
        d(`Recursive compile failed - intermediate result: ${JSON.stringify(result)}`);

        throw new Error(`Compiling ${filePath} resulted in a MIME type of ${result.mimeType}, which we don't know how to handle`);
      }

      return this.compileUncachedSync(`${filePath}.${_mimeTypes2.default.extension(result.mimeType || 'txt')}`, hashInfo, compiler);
    }
  }

  compileAllSync(rootDirectory) {
    let shouldCompile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    let should = shouldCompile || function () {
      return true;
    };

    (0, _forAllFiles.forAllFilesSync)(rootDirectory, f => {
      if (!should(f)) return;
      return this.compileSync(f, this.compilersByMimeType);
    });
  }

  /*
   * Other stuff
   */

  /**
   * Returns the passthrough compiler
   *
   * @private
   */
  getPassthroughCompiler() {
    return this.compilersByMimeType['text/plain'];
  }

  /**
   * Determines whether we should even try to compile the content. Note that in
   * some cases, content will still be in cache even if this returns true, and
   * in other cases (isInNodeModules), we'll know explicitly to not even bother
   * looking in the cache.
   *
   * @private
   */
  static shouldPassthrough(hashInfo) {
    return hashInfo.isMinified || hashInfo.isInNodeModules || hashInfo.hasSourceMap || hashInfo.isFileBinary;
  }

  /**
   * Look at the code of a node modules and see the sourceMapping path.
   * If there is any, check the path and try to fix it with and
   * root relative path.
   * @private
   */
  static fixNodeModulesSourceMapping(sourceCode, sourcePath, appRoot) {
    return _asyncToGenerator(function* () {
      let regexSourceMapping = /\/\/#.*sourceMappingURL=(?!data:)([^"'].*)/i;
      let sourceMappingCheck = sourceCode.match(regexSourceMapping);

      if (sourceMappingCheck && sourceMappingCheck[1] && sourceMappingCheck[1] !== '') {
        let sourceMapPath = sourceMappingCheck[1];

        try {
          yield _promise.pfs.stat(sourceMapPath);
        } catch (error) {
          let normRoot = _path2.default.normalize(appRoot);
          let absPathToModule = _path2.default.dirname(sourcePath.replace(normRoot, '').substring(1));
          let newMapPath = _path2.default.join(absPathToModule, sourceMapPath);

          return sourceCode.replace(regexSourceMapping, `//# sourceMappingURL=${newMapPath}`);
        }
      }

      return sourceCode;
    })();
  }

  /**
   * Look at the code of a node modules and see the sourceMapping path.
   * If there is any, check the path and try to fix it with and
   * root relative path.
   * @private
   */
  static fixNodeModulesSourceMappingSync(sourceCode, sourcePath, appRoot) {
    let regexSourceMapping = /\/\/#.*sourceMappingURL=(?!data:)([^"'].*)/i;
    let sourceMappingCheck = sourceCode.match(regexSourceMapping);

    if (sourceMappingCheck && sourceMappingCheck[1] && sourceMappingCheck[1] !== '') {
      let sourceMapPath = sourceMappingCheck[1];

      try {
        _fs2.default.statSync(sourceMapPath);
      } catch (error) {
        let normRoot = _path2.default.normalize(appRoot);
        let absPathToModule = _path2.default.dirname(sourcePath.replace(normRoot, '').substring(1));
        let newMapPath = _path2.default.join(absPathToModule, sourceMapPath);

        return sourceCode.replace(regexSourceMapping, `//# sourceMappingURL=${newMapPath}`);
      }
    }

    return sourceCode;
  }
}
exports.default = CompilerHost;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21waWxlci1ob3N0LmpzIl0sIm5hbWVzIjpbImQiLCJyZXF1aXJlIiwiaW5pdCIsImZpbmFsRm9ybXMiLCJDb21waWxlckhvc3QiLCJjb25zdHJ1Y3RvciIsInJvb3RDYWNoZURpciIsImNvbXBpbGVycyIsImZpbGVDaGFuZ2VDYWNoZSIsInJlYWRPbmx5TW9kZSIsImZhbGxiYWNrQ29tcGlsZXIiLCJzb3VyY2VNYXBQYXRoIiwiY29tcGlsZXJzQnlNaW1lVHlwZSIsIk9iamVjdCIsImFzc2lnbiIsImFwcFJvb3QiLCJjYWNoZXNGb3JDb21waWxlcnMiLCJrZXlzIiwicmVkdWNlIiwiYWNjIiwieCIsImNvbXBpbGVyIiwiaGFzIiwic2V0IiwiY3JlYXRlRnJvbUNvbXBpbGVyIiwiTWFwIiwiY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvbiIsInRhcmdldCIsImpvaW4iLCJidWYiLCJyZWFkRmlsZSIsImluZm8iLCJKU09OIiwicGFyc2UiLCJndW56aXAiLCJsb2FkRnJvbURhdGEiLCJjdXIiLCJuYW1lIiwiY29tcGlsZXJWZXJzaW9uIiwiY29tcGlsZXJPcHRpb25zIiwiaW5wdXRNaW1lVHlwZXMiLCJjcmVhdGVGcm9tQ29uZmlndXJhdGlvbiIsImZvckVhY2giLCJzYXZlQ29uZmlndXJhdGlvbiIsInNlcmlhbGl6ZWRDb21waWxlck9wdHMiLCJLbGFzcyIsImdldFByb3RvdHlwZU9mIiwidmFsIiwiZ2V0SW5wdXRNaW1lVHlwZXMiLCJnZXRDb21waWxlclZlcnNpb24iLCJnZXRTYXZlZERhdGEiLCJnemlwIiwiQnVmZmVyIiwic3RyaW5naWZ5Iiwid3JpdGVGaWxlIiwiY29tcGlsZSIsImZpbGVQYXRoIiwiY29tcGlsZVJlYWRPbmx5IiwiZnVsbENvbXBpbGUiLCJ0eXBlIiwibG9va3VwIiwiaXNJbk5vZGVNb2R1bGVzIiwibWltZVR5cGUiLCJjb2RlIiwiaGFzaEluZm8iLCJnZXRIYXNoRm9yUGF0aCIsInNob3VsZFBhc3N0aHJvdWdoIiwiZ2V0UGFzc3Rocm91Z2hDb21waWxlciIsImdldCIsImJpbmFyeURhdGEiLCJjYWNoZSIsIkVycm9yIiwic291cmNlQ29kZSIsImZpeE5vZGVNb2R1bGVzU291cmNlTWFwcGluZyIsImdldE9yRmV0Y2giLCJjb21waWxlVW5jYWNoZWQiLCJpbnB1dE1pbWVUeXBlIiwiaXNGaWxlQmluYXJ5IiwiZGVwZW5kZW50RmlsZXMiLCJjdHgiLCJzaG91bGRDb21waWxlRmlsZSIsImRldGVybWluZURlcGVuZGVudEZpbGVzIiwicmVzdWx0Iiwic2hvdWxkSW5saW5lSHRtbGlmeSIsImlzUGFzc3Rocm91Z2giLCJleHRlbnNpb24iLCJjb21waWxlQWxsIiwicm9vdERpcmVjdG9yeSIsInNob3VsZENvbXBpbGUiLCJzaG91bGQiLCJmIiwibGlzdGVuVG9Db21waWxlRXZlbnRzIiwibWFwIiwiY29tcGlsZVN5bmMiLCJjb21waWxlUmVhZE9ubHlTeW5jIiwiZnVsbENvbXBpbGVTeW5jIiwiY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvblN5bmMiLCJyZWFkRmlsZVN5bmMiLCJndW56aXBTeW5jIiwiY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb25TeW5jIiwic2F2ZUNvbmZpZ3VyYXRpb25TeW5jIiwiZ3ppcFN5bmMiLCJ3cml0ZUZpbGVTeW5jIiwiZ2V0SGFzaEZvclBhdGhTeW5jIiwiZ2V0U3luYyIsImZpeE5vZGVNb2R1bGVzU291cmNlTWFwcGluZ1N5bmMiLCJnZXRPckZldGNoU3luYyIsImNvbXBpbGVVbmNhY2hlZFN5bmMiLCJzaG91bGRDb21waWxlRmlsZVN5bmMiLCJkZXRlcm1pbmVEZXBlbmRlbnRGaWxlc1N5bmMiLCJjb21waWxlQWxsU3luYyIsImlzTWluaWZpZWQiLCJoYXNTb3VyY2VNYXAiLCJzb3VyY2VQYXRoIiwicmVnZXhTb3VyY2VNYXBwaW5nIiwic291cmNlTWFwcGluZ0NoZWNrIiwibWF0Y2giLCJzdGF0IiwiZXJyb3IiLCJub3JtUm9vdCIsIm5vcm1hbGl6ZSIsImFic1BhdGhUb01vZHVsZSIsImRpcm5hbWUiLCJyZXBsYWNlIiwic3Vic3RyaW5nIiwibmV3TWFwUGF0aCIsInN0YXRTeW5jIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBSUE7Ozs7OztBQUZBLE1BQU1BLElBQUlDLFFBQVEsT0FBUixFQUFpQixnQ0FBakIsQ0FBVjs7QUFJQUEsUUFBUSxrQkFBUixFQUE0QkMsSUFBNUI7O0FBRUE7QUFDQSxNQUFNQyxhQUFhO0FBQ2pCLHFCQUFtQixJQURGO0FBRWpCLDRCQUEwQixJQUZUO0FBR2pCLGVBQWEsSUFISTtBQUlqQixjQUFZLElBSks7QUFLakIsbUJBQWlCLElBTEE7QUFNakIsc0JBQW9CO0FBTkgsQ0FBbkI7O0FBU0E7Ozs7Ozs7Ozs7Ozs7O0FBY2UsTUFBTUMsWUFBTixDQUFtQjtBQUNoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBQyxjQUFZQyxZQUFaLEVBQTBCQyxTQUExQixFQUFxQ0MsZUFBckMsRUFBc0RDLFlBQXRELEVBQW1IO0FBQUEsUUFBL0NDLGdCQUErQyx1RUFBNUIsSUFBNEI7QUFBQSxRQUF0QkMsYUFBc0IsdUVBQU4sSUFBTTs7QUFDakgsUUFBSUMsc0JBQXNCQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQlAsU0FBbEIsQ0FBMUI7QUFDQU0sV0FBT0MsTUFBUCxDQUFjLElBQWQsRUFBb0IsRUFBQ1IsWUFBRCxFQUFlTSxtQkFBZixFQUFvQ0osZUFBcEMsRUFBcURDLFlBQXJELEVBQW1FQyxnQkFBbkUsRUFBcEI7QUFDQSxTQUFLSyxPQUFMLEdBQWUsS0FBS1AsZUFBTCxDQUFxQk8sT0FBcEM7O0FBRUEsU0FBS0Msa0JBQUwsR0FBMEJILE9BQU9JLElBQVAsQ0FBWUwsbUJBQVosRUFBaUNNLE1BQWpDLENBQXdDLENBQUNDLEdBQUQsRUFBTUMsQ0FBTixLQUFZO0FBQzVFLFVBQUlDLFdBQVdULG9C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QSxRQUFJQyxzQkFBc0JBLG1CQUFtQixDQUFuQixDQUF0QixJQUErQ0EsbUJBQW1CLENBQW5CLE1BQTBCLEVBQTdFLEVBQWdGO0FBQzlFLFVBQUl4RyxnQkFBZ0J3RyxtQkFBbUIsQ0FBbkIsQ0FBcEI7O0FBRUEsVUFBSTtBQUNGLHFCQUFHVyxRQUFILENBQVluSCxhQUFaO0FBQ0QsT0FGRCxDQUVFLE9BQU8yRyxLQUFQLEVBQWM7QUFDZCxZQUFJQyxXQUFXLGVBQUtDLFNBQUwsQ0FBZXpHLE9BQWYsQ0FBZjtBQUNBLFlBQUkwRyxrQkFBa0IsZUFBS0MsT0FBTCxDQUFhVCxXQUFXVSxPQUFYLENBQW1CSixRQUFuQixFQUE2QixFQUE3QixFQUFpQ0ssU0FBakMsQ0FBMkMsQ0FBM0MsQ0FBYixDQUF0QjtBQUNBLFlBQUlDLGFBQWEsZUFBS2pHLElBQUwsQ0FBVTZGLGVBQVYsRUFBMkI5RyxhQUEzQixDQUFqQjs7QUFFQSxlQUFPNkQsV0FBV21ELE9BQVgsQ0FBbUJULGtCQUFuQixFQUF3Qyx3QkFBdUJXLFVBQVcsRUFBMUUsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsV0FBT3JELFVBQVA7QUFDRDtBQXpvQitCO2tCQUFicEUsWSIsImZpbGUiOiJjb21waWxlci1ob3N0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1pbWVUeXBlcyBmcm9tICdAcGF1bGNiZXR0cy9taW1lLXR5cGVzJztcclxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQge3BmcywgcHpsaWJ9IGZyb20gJy4vcHJvbWlzZSc7XHJcblxyXG5pbXBvcnQge2ZvckFsbEZpbGVzLCBmb3JBbGxGaWxlc1N5bmN9IGZyb20gJy4vZm9yLWFsbC1maWxlcyc7XHJcbmltcG9ydCBDb21waWxlQ2FjaGUgZnJvbSAnLi9jb21waWxlLWNhY2hlJztcclxuaW1wb3J0IEZpbGVDaGFuZ2VkQ2FjaGUgZnJvbSAnLi9maWxlLWNoYW5nZS1jYWNoZSc7XHJcbmltcG9ydCBSZWFkT25seUNvbXBpbGVyIGZyb20gJy4vcmVhZC1vbmx5LWNvbXBpbGVyJztcclxuaW1wb3J0IHtsaXN0ZW4sIHNlbmR9IGZyb20gJy4vYnJvd3Nlci1zaWduYWwnO1xyXG5cclxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGU6Y29tcGlsZXItaG9zdCcpO1xyXG5cclxuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tYXAnO1xyXG5cclxucmVxdWlyZSgnLi9yaWctbWltZS10eXBlcycpLmluaXQoKTtcclxuXHJcbi8vIFRoaXMgaXNuJ3QgZXZlbiBteVxyXG5jb25zdCBmaW5hbEZvcm1zID0ge1xyXG4gICd0ZXh0L2phdmFzY3JpcHQnOiB0cnVlLFxyXG4gICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JzogdHJ1ZSxcclxuICAndGV4dC9odG1sJzogdHJ1ZSxcclxuICAndGV4dC9jc3MnOiB0cnVlLFxyXG4gICdpbWFnZS9zdmcreG1sJzogdHJ1ZSxcclxuICAnYXBwbGljYXRpb24vanNvbic6IHRydWVcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGlzIHRoZSB0b3AtbGV2ZWwgY2xhc3MgdGhhdCBlbmNhcHN1bGF0ZXMgYWxsIG9mIHRoZSBsb2dpYyBvZlxyXG4gKiBjb21waWxpbmcgYW5kIGNhY2hpbmcgYXBwbGljYXRpb24gY29kZS4gSWYgeW91J3JlIGxvb2tpbmcgZm9yIGEgXCJNYWluIGNsYXNzXCIsXHJcbiAqIHRoaXMgaXMgaXQuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgY2FuIGJlIGNyZWF0ZWQgZGlyZWN0bHkgYnV0IGl0IGlzIHVzdWFsbHkgY3JlYXRlZCB2aWEgdGhlIG1ldGhvZHNcclxuICogaW4gY29uZmlnLXBhcnNlciwgd2hpY2ggd2lsbCBhbW9uZyBvdGhlciB0aGluZ3MsIHNldCB1cCB0aGUgY29tcGlsZXIgb3B0aW9uc1xyXG4gKiBnaXZlbiBhIHByb2plY3Qgcm9vdC5cclxuICpcclxuICogQ29tcGlsZXJIb3N0IGlzIGFsc28gdGhlIHRvcC1sZXZlbCBjbGFzcyB0aGF0IGtub3dzIGhvdyB0byBzZXJpYWxpemUgYWxsIG9mIHRoZVxyXG4gKiBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gcmVjcmVhdGUgaXRzZWxmLCBlaXRoZXIgYXMgYSBkZXZlbG9wbWVudCBob3N0IChpLmUuXHJcbiAqIHdpbGwgYWxsb3cgY2FjaGUgbWlzc2VzIGFuZCBhY3R1YWwgY29tcGlsYXRpb24pLCBvciBhcyBhIHJlYWQtb25seSB2ZXJzaW9uIG9mXHJcbiAqIGl0c2VsZiBmb3IgcHJvZHVjdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBpbGVySG9zdCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBDb21waWxlckhvc3QuIFlvdSBwcm9iYWJseSB3YW50IHRvIHVzZSB0aGUgbWV0aG9kc1xyXG4gICAqIGluIGNvbmZpZy1wYXJzZXIgZm9yIGRldmVsb3BtZW50LCBvciB7QGxpbmsgY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvbn1cclxuICAgKiBmb3IgcHJvZHVjdGlvbiBpbnN0ZWFkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgIFRoZSByb290IGRpcmVjdG9yeSB0byB1c2UgZm9yIHRoZSBjYWNoZVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb21waWxlcnMgIGFuIE9iamVjdCB3aG9zZSBrZXlzIGFyZSBpbnB1dCBNSU1FIHR5cGVzIGFuZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aG9zZSB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiBDb21waWxlckJhc2UuIENyZWF0ZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHZpYSB0aGUge0BsaW5rIGNyZWF0ZUNvbXBpbGVyc30gbWV0aG9kIGluXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy1wYXJzZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtGaWxlQ2hhbmdlZENhY2hlfSBmaWxlQ2hhbmdlQ2FjaGUgIEEgZmlsZS1jaGFuZ2UgY2FjaGUgdGhhdCBpc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxseSBwcmUtbG9hZGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gcmVhZE9ubHlNb2RlICBJZiBUcnVlLCBjYWNoZSBtaXNzZXMgd2lsbCBmYWlsIGFuZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGlsYXRpb24gd2lsbCBub3QgYmUgYXR0ZW1wdGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Q29tcGlsZXJCYXNlfSBmYWxsYmFja0NvbXBpbGVyIChvcHRpb25hbCkgIFdoZW4gYSBmaWxlIGlzIGNvbXBpbGVkXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIGNvbXBpbGVyLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGNvbXBpbGVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBJZlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCB3aWxsIGZhaWwgY29tcGlsYXRpb24uIEEgZ29vZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGUgZmFsbGJhY2sgaXMgdGhlIGNvbXBpbGVyIGZvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dC9wbGFpbicsIHdoaWNoIGlzIGd1YXJhbnRlZWQgdG8gYmVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VNYXBQYXRoIChvcHRpb25hbCkgVGhlIGRpcmVjdG9yeSB0byBzdG9yZSBzb3VyY2VtYXAgc2VwYXJhdGVseVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGNvbXBpbGVyIG9wdGlvbiBlbmFibGVkIHRvIGVtaXQuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB0byBjYWNoZVBhdGggaWYgbm90IHNwZWNpZmllZC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihyb290Q2FjaGVEaXIsIGNvbXBpbGVycywgZmlsZUNoYW5nZUNhY2hlLCByZWFkT25seU1vZGUsIGZhbGxiYWNrQ29tcGlsZXIgPSBudWxsLCBzb3VyY2VNYXBQYXRoID0gbnVsbCkge1xyXG4gICAgbGV0IGNvbXBpbGVyc0J5TWltZVR5cGUgPSBPYmplY3QuYXNzaWduKHt9LCBjb21waWxlcnMpO1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7cm9vdENhY2hlRGlyLCBjb21waWxlcnNCeU1pbWVUeXBlLCBmaWxlQ2hhbmdlQ2FjaGUsIHJlYWRPbmx5TW9kZSwgZmFsbGJhY2tDb21waWxlcn0pO1xyXG4gICAgdGhpcy5hcHBSb290ID0gdGhpcy5maWxlQ2hhbmdlQ2FjaGUuYXBwUm9vdDtcclxuXHJcbiAgICB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycyA9IE9iamVjdC5rZXlzKGNvbXBpbGVyc0J5TWltZVR5cGUpLnJlZHVjZSgoYWNjLCB4KSA9PiB7XHJcbiAgICAgIGxldCBjb21waWxlciA9IGNvbXBpbGVyc0J5TWltZVR5cGVbeF07XHJcbiAgICAgIGlmIChhY2MuaGFzKGNvbXBpbGVyKSkgcmV0dXJuIGFjYztcclxuXHJcbiAgICAgIGFjYy5zZXQoXHJcbiAgICAgICAgY29tcGlsZXIsXHJcbiAgICAgICAgQ29tcGlsZUNhY2hlLmNyZWF0ZUZyb21Db21waWxlcihyb290Q2FjaGVEaXIsIGNvbXBpbGVyLCBmaWxlQ2hhbmdlQ2FjaGUsIHJlYWRPbmx5TW9kZSwgc291cmNlTWFwUGF0aCkpO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwgbmV3IE1hcCgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBwcm9kdWN0aW9uLW1vZGUgQ29tcGlsZXJIb3N0IGZyb20gdGhlIHByZXZpb3VzbHkgc2F2ZWRcclxuICAgKiBjb25maWd1cmF0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAgVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHVzZSBmb3IgdGhlIGNhY2hlLiBUaGlzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlIG11c3QgaGF2ZSBjYWNoZSBpbmZvcm1hdGlvbiBzYXZlZCB2aWFcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIHNhdmVDb25maWd1cmF0aW9ufVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhcHBSb290ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSBmb3IgeW91ciBhcHBsaWNhdGlvbiAoaS5lLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Q29tcGlsZXJCYXNlfSBmYWxsYmFja0NvbXBpbGVyIChvcHRpb25hbCkgIFdoZW4gYSBmaWxlIGlzIGNvbXBpbGVkXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIGNvbXBpbGVyLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGNvbXBpbGVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBJZlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCB3aWxsIGZhaWwgY29tcGlsYXRpb24uIEEgZ29vZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGUgZmFsbGJhY2sgaXMgdGhlIGNvbXBpbGVyIGZvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dC9wbGFpbicsIHdoaWNoIGlzIGd1YXJhbnRlZWQgdG8gYmVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8Q29tcGlsZXJIb3N0Pn0gIEEgcmVhZC1vbmx5IENvbXBpbGVySG9zdFxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9uKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgZmFsbGJhY2tDb21waWxlcj1udWxsKSB7XHJcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHBmcy5yZWFkRmlsZSh0YXJnZXQpO1xyXG4gICAgbGV0IGluZm8gPSBKU09OLnBhcnNlKGF3YWl0IHB6bGliLmd1bnppcChidWYpKTtcclxuXHJcbiAgICBsZXQgZmlsZUNoYW5nZUNhY2hlID0gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoaW5mby5maWxlQ2hhbmdlQ2FjaGUsIGFwcFJvb3QsIHRydWUpO1xyXG5cclxuICAgIGxldCBjb21waWxlcnMgPSBPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycykucmVkdWNlKChhY2MsIHgpID0+IHtcclxuICAgICAgbGV0IGN1ciA9IGluZm8uY29tcGlsZXJzW3hdO1xyXG4gICAgICBhY2NbeF0gPSBuZXcgUmVhZE9ubHlDb21waWxlcihjdXIubmFtZSwgY3VyLmNvbXBpbGVyVmVyc2lvbiwgY3VyLmNvbXBpbGVyT3B0aW9ucywgY3VyLmlucHV0TWltZVR5cGVzKTtcclxuXHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB7fSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnMsIGZpbGVDaGFuZ2VDYWNoZSwgdHJ1ZSwgZmFsbGJhY2tDb21waWxlcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgZGV2ZWxvcG1lbnQtbW9kZSBDb21waWxlckhvc3QgZnJvbSB0aGUgcHJldmlvdXNseSBzYXZlZFxyXG4gICAqIGNvbmZpZ3VyYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAgVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHVzZSBmb3IgdGhlIGNhY2hlLiBUaGlzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlIG11c3QgaGF2ZSBjYWNoZSBpbmZvcm1hdGlvbiBzYXZlZCB2aWFcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIHNhdmVDb25maWd1cmF0aW9ufVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhcHBSb290ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSBmb3IgeW91ciBhcHBsaWNhdGlvbiAoaS5lLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb21waWxlcnNCeU1pbWVUeXBlICBhbiBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgaW5wdXQgTUlNRVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMgYW5kIHdob3NlIHZhbHVlcyBhcmUgaW5zdGFuY2VzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBDb21waWxlckJhc2UuIENyZWF0ZSB0aGlzIHZpYSB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBjcmVhdGVDb21waWxlcnN9IG1ldGhvZCBpblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLXBhcnNlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0NvbXBpbGVyQmFzZX0gZmFsbGJhY2tDb21waWxlciAob3B0aW9uYWwpICBXaGVuIGEgZmlsZSBpcyBjb21waWxlZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBkb2Vzbid0IGhhdmUgYSBtYXRjaGluZyBjb21waWxlcixcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBjb21waWxlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gSWZcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgd2lsbCBmYWlsIGNvbXBpbGF0aW9uLiBBIGdvb2RcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRlIGZhbGxiYWNrIGlzIHRoZSBjb21waWxlciBmb3JcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQvcGxhaW4nLCB3aGljaCBpcyBndWFyYW50ZWVkIHRvIGJlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbXBpbGVySG9zdD59ICBBIHJlYWQtb25seSBDb21waWxlckhvc3RcclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb24ocm9vdENhY2hlRGlyLCBhcHBSb290LCBjb21waWxlcnNCeU1pbWVUeXBlLCBmYWxsYmFja0NvbXBpbGVyPW51bGwpIHtcclxuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XHJcbiAgICBsZXQgYnVmID0gYXdhaXQgcGZzLnJlYWRGaWxlKHRhcmdldCk7XHJcbiAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoYXdhaXQgcHpsaWIuZ3VuemlwKGJ1ZikpO1xyXG5cclxuICAgIGxldCBmaWxlQ2hhbmdlQ2FjaGUgPSBGaWxlQ2hhbmdlZENhY2hlLmxvYWRGcm9tRGF0YShpbmZvLmZpbGVDaGFuZ2VDYWNoZSwgYXBwUm9vdCwgZmFsc2UpO1xyXG5cclxuICAgIE9iamVjdC5rZXlzKGluZm8uY29tcGlsZXJzKS5mb3JFYWNoKCh4KSA9PiB7XHJcbiAgICAgIGxldCBjdXIgPSBpbmZvLmNvbXBpbGVyc1t4XTtcclxuICAgICAgY29tcGlsZXJzQnlNaW1lVHlwZVt4XS5jb21waWxlck9wdGlvbnMgPSBjdXIuY29tcGlsZXJPcHRpb25zO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnNCeU1pbWVUeXBlLCBmaWxlQ2hhbmdlQ2FjaGUsIGZhbHNlLCBmYWxsYmFja0NvbXBpbGVyKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBTYXZlcyB0aGUgY3VycmVudCBjb21waWxlciBjb25maWd1cmF0aW9uIHRvIGEgZmlsZSB0aGF0XHJcbiAgICoge0BsaW5rIGNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb259IGNhbiB1c2UgdG8gcmVjcmVhdGUgdGhlIGN1cnJlbnRcclxuICAgKiBjb21waWxlciBlbnZpcm9ubWVudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gIENvbXBsZXRpb25cclxuICAgKi9cclxuICBhc3luYyBzYXZlQ29uZmlndXJhdGlvbigpIHtcclxuICAgIGxldCBzZXJpYWxpemVkQ29tcGlsZXJPcHRzID0gT2JqZWN0LmtleXModGhpcy5jb21waWxlcnNCeU1pbWVUeXBlKS5yZWR1Y2UoKGFjYywgeCkgPT4ge1xyXG4gICAgICBsZXQgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbeF07XHJcbiAgICAgIGxldCBLbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21waWxlcikuY29uc3RydWN0b3I7XHJcblxyXG4gICAgICBsZXQgdmFsID0ge1xyXG4gICAgICAgIG5hbWU6IEtsYXNzLm5hbWUsXHJcbiAgICAgICAgaW5wdXRNaW1lVHlwZXM6IEtsYXNzLmdldElucHV0TWltZVR5cGVzKCksXHJcbiAgICAgICAgY29tcGlsZXJPcHRpb25zOiBjb21waWxlci5jb21waWxlck9wdGlvbnMsXHJcbiAgICAgICAgY29tcGlsZXJWZXJzaW9uOiBjb21waWxlci5nZXRDb21waWxlclZlcnNpb24oKVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgYWNjW3hdID0gdmFsO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30pO1xyXG5cclxuICAgIGxldCBpbmZvID0ge1xyXG4gICAgICBmaWxlQ2hhbmdlQ2FjaGU6IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldFNhdmVkRGF0YSgpLFxyXG4gICAgICBjb21waWxlcnM6IHNlcmlhbGl6ZWRDb21waWxlck9wdHNcclxuICAgIH07XHJcblxyXG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbih0aGlzLnJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHB6bGliLmd6aXAobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeShpbmZvKSkpO1xyXG4gICAgYXdhaXQgcGZzLndyaXRlRmlsZSh0YXJnZXQsIGJ1Zik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21waWxlcyBhIGZpbGUgYW5kIHJldHVybnMgdGhlIGNvbXBpbGVkIHJlc3VsdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZVBhdGggIFRoZSBwYXRoIHRvIHRoZSBmaWxlIHRvIGNvbXBpbGVcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8b2JqZWN0Pn0gIEFuIE9iamVjdCB3aXRoIHRoZSBjb21waWxlZCByZXN1bHRcclxuICAgKlxyXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBoYXNoSW5mbyAgVGhlIGhhc2ggaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBnZXRIYXNoRm9yUGF0aFxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2RlICBUaGUgc291cmNlIGNvZGUgaWYgdGhlIGZpbGUgd2FzIGEgdGV4dCBmaWxlXHJcbiAgICogQHByb3BlcnR5IHtCdWZmZXJ9IGJpbmFyeURhdGEgIFRoZSBmaWxlIGlmIGl0IHdhcyBhIGJpbmFyeSBmaWxlXHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IG1pbWVUeXBlICBUaGUgTUlNRSB0eXBlIHNhdmVkIGluIHRoZSBjYWNoZS5cclxuICAgKiBAcHJvcGVydHkge3N0cmluZ1tdfSBkZXBlbmRlbnRGaWxlcyAgVGhlIGRlcGVuZGVudCBmaWxlcyByZXR1cm5lZCBmcm9tXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGluZyB0aGUgZmlsZSwgaWYgYW55LlxyXG4gICAqL1xyXG4gIGNvbXBpbGUoZmlsZVBhdGgpIHtcclxuICAgIHJldHVybiAodGhpcy5yZWFkT25seU1vZGUgPyB0aGlzLmNvbXBpbGVSZWFkT25seShmaWxlUGF0aCkgOiB0aGlzLmZ1bGxDb21waWxlKGZpbGVQYXRoKSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBjb21waWxhdGlvbiBpbiByZWFkLW9ubHkgbW9kZVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBhc3luYyBjb21waWxlUmVhZE9ubHkoZmlsZVBhdGgpIHtcclxuICAgIC8vIFdlIGd1YXJhbnRlZSB0aGF0IG5vZGVfbW9kdWxlcyBhcmUgYWx3YXlzIHNoaXBwZWQgZGlyZWN0bHlcclxuICAgIGxldCB0eXBlID0gbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCk7XHJcbiAgICBpZiAoRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoZmlsZVBhdGgpKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbWltZVR5cGU6IHR5cGUgfHwgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxyXG4gICAgICAgIGNvZGU6IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBoYXNoSW5mbyA9IGF3YWl0IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoKGZpbGVQYXRoKTtcclxuXHJcbiAgICAvLyBOQjogSGVyZSwgd2UncmUgYmFzaWNhbGx5IG9ubHkgdXNpbmcgdGhlIGNvbXBpbGVyIGhlcmUgdG8gZmluZFxyXG4gICAgLy8gdGhlIGFwcHJvcHJpYXRlIENvbXBpbGVDYWNoZVxyXG4gICAgbGV0IGNvbXBpbGVyID0gQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSA/XHJcbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcclxuICAgICAgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3R5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xyXG5cclxuXHJcbiAgICAvLyBOQjogV2UgZG9uJ3QgcHV0IHRoaXMgaW50byBzaG91bGRQYXNzdGhyb3VnaCBiZWNhdXNlIElubGluZSBIVE1MXHJcbiAgICAvLyBjb21waWxlciBpcyB0ZWNobmljYWxseSBvZiB0eXBlIGZpbmFsRm9ybXMgKGkuZS4gYSBicm93c2VyIGNhblxyXG4gICAgLy8gbmF0aXZlbHkgaGFuZGxlIHRoaXMgY29udGVudCksIHlldCBpdHMgY29tcGlsZXIgaXNcclxuICAgIC8vIElubGluZUh0bWxDb21waWxlci4gSG93ZXZlciwgd2Ugc3RpbGwgd2FudCB0byBjYXRjaCBzdGFuZGFyZCBDU1MgZmlsZXNcclxuICAgIC8vIHdoaWNoIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IFBhc3N0aHJvdWdoQ29tcGlsZXIuXHJcbiAgICBpZiAoZmluYWxGb3Jtc1t0eXBlXSAmJiAhY29tcGlsZXIpIHtcclxuICAgICAgY29tcGlsZXIgPSB0aGlzLmdldFBhc3N0aHJvdWdoQ29tcGlsZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNvbXBpbGVyKSB7XHJcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5mYWxsYmFja0NvbXBpbGVyO1xyXG5cclxuICAgICAgbGV0IHsgY29kZSwgYmluYXJ5RGF0YSwgbWltZVR5cGUgfSA9IGF3YWl0IGNvbXBpbGVyLmdldChmaWxlUGF0aCk7XHJcbiAgICAgIHJldHVybiB7IGNvZGU6IGNvZGUgfHwgYmluYXJ5RGF0YSwgbWltZVR5cGUgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FjaGUgPSB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycy5nZXQoY29tcGlsZXIpO1xyXG4gICAgbGV0IHtjb2RlLCBiaW5hcnlEYXRhLCBtaW1lVHlwZX0gPSBhd2FpdCBjYWNoZS5nZXQoZmlsZVBhdGgpO1xyXG5cclxuICAgIGNvZGUgPSBjb2RlIHx8IGJpbmFyeURhdGE7XHJcbiAgICBpZiAoIWNvZGUgfHwgIW1pbWVUeXBlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgdG8gY29tcGlsZSAke2ZpbGVQYXRofSBpbiBwcm9kdWN0aW9uLCBpcyB0aGlzIGZpbGUgbm90IHByZWNvbXBpbGVkP2ApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIGNvbXBpbGF0aW9uIGluIHJlYWQtd3JpdGUgbW9kZVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBhc3luYyBmdWxsQ29tcGlsZShmaWxlUGF0aCkge1xyXG4gICAgZChgQ29tcGlsaW5nICR7ZmlsZVBhdGh9YCk7XHJcblxyXG4gICAgbGV0IGhhc2hJbmZvID0gYXdhaXQgdGhpcy5maWxlQ2hhbmdlQ2FjaGUuZ2V0SGFzaEZvclBhdGgoZmlsZVBhdGgpO1xyXG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcclxuXHJcbiAgICBzZW5kKCdlbGVjdHJvbi1jb21waWxlLWNvbXBpbGVkLWZpbGUnLCB7IGZpbGVQYXRoLCBtaW1lVHlwZTogdHlwZSB9KTtcclxuXHJcbiAgICBpZiAoaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzKSB7XHJcbiAgICAgIGxldCBjb2RlID0gaGFzaEluZm8uc291cmNlQ29kZSB8fCBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4Jyk7XHJcbiAgICAgIGNvZGUgPSBhd2FpdCBDb21waWxlckhvc3QuZml4Tm9kZU1vZHVsZXNTb3VyY2VNYXBwaW5nKGNvZGUsIGZpbGVQYXRoLCB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5hcHBSb290KTtcclxuICAgICAgcmV0dXJuIHsgY29kZSwgbWltZVR5cGU6IHR5cGUgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY29tcGlsZXIgPSBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pID9cclxuICAgICAgdGhpcy5nZXRQYXNzdGhyb3VnaENvbXBpbGVyKCkgOlxyXG4gICAgICB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbdHlwZSB8fCAnX19sb2xub3RoZXJlJ107XHJcblxyXG4gICAgaWYgKCFjb21waWxlcikge1xyXG4gICAgICBkKGBGYWxsaW5nIGJhY2sgdG8gcGFzc3Rocm91Z2ggY29tcGlsZXIgZm9yICR7ZmlsZVBhdGh9YCk7XHJcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5mYWxsYmFja0NvbXBpbGVyO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29tcGlsZXIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG4ndCBmaW5kIGEgY29tcGlsZXIgZm9yICR7ZmlsZVBhdGh9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNhY2hlID0gdGhpcy5jYWNoZXNGb3JDb21waWxlcnMuZ2V0KGNvbXBpbGVyKTtcclxuICAgIHJldHVybiBhd2FpdCBjYWNoZS5nZXRPckZldGNoKFxyXG4gICAgICBmaWxlUGF0aCxcclxuICAgICAgKGZpbGVQYXRoLCBoYXNoSW5mbykgPT4gdGhpcy5jb21waWxlVW5jYWNoZWQoZmlsZVBhdGgsIGhhc2hJbmZvLCBjb21waWxlcikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBpbnZva2luZyBjb21waWxlcnMgaW5kZXBlbmRlbnQgb2YgY2FjaGluZ1xyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBhc3luYyBjb21waWxlVW5jYWNoZWQoZmlsZVBhdGgsIGhhc2hJbmZvLCBjb21waWxlcikge1xyXG4gICAgbGV0IGlucHV0TWltZVR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcclxuXHJcbiAgICBpZiAoaGFzaEluZm8uaXNGaWxlQmluYXJ5KSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgYmluYXJ5RGF0YTogaGFzaEluZm8uYmluYXJ5RGF0YSB8fCBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZVBhdGgpLFxyXG4gICAgICAgIG1pbWVUeXBlOiBpbnB1dE1pbWVUeXBlLFxyXG4gICAgICAgIGRlcGVuZGVudEZpbGVzOiBbXVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjdHggPSB7fTtcclxuICAgIGxldCBjb2RlID0gaGFzaEluZm8uc291cmNlQ29kZSB8fCBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4Jyk7XHJcblxyXG4gICAgaWYgKCEoYXdhaXQgY29tcGlsZXIuc2hvdWxkQ29tcGlsZUZpbGUoY29kZSwgY3R4KSkpIHtcclxuICAgICAgZChgQ29tcGlsZXIgcmV0dXJuZWQgZmFsc2UgZm9yIHNob3VsZENvbXBpbGVGaWxlOiAke2ZpbGVQYXRofWApO1xyXG4gICAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZTogbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCksIGRlcGVuZGVudEZpbGVzOiBbXSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBkZXBlbmRlbnRGaWxlcyA9IGF3YWl0IGNvbXBpbGVyLmRldGVybWluZURlcGVuZGVudEZpbGVzKGNvZGUsIGZpbGVQYXRoLCBjdHgpO1xyXG5cclxuICAgIGQoYFVzaW5nIGNvbXBpbGVyIG9wdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkoY29tcGlsZXIuY29tcGlsZXJPcHRpb25zKX1gKTtcclxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjb21waWxlci5jb21waWxlKGNvZGUsIGZpbGVQYXRoLCBjdHgpO1xyXG5cclxuICAgIGxldCBzaG91bGRJbmxpbmVIdG1saWZ5ID1cclxuICAgICAgaW5wdXRNaW1lVHlwZSAhPT0gJ3RleHQvaHRtbCcgJiZcclxuICAgICAgcmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9odG1sJztcclxuXHJcbiAgICBsZXQgaXNQYXNzdGhyb3VnaCA9XHJcbiAgICAgIHJlc3VsdC5taW1lVHlwZSA9PT0gJ3RleHQvcGxhaW4nIHx8XHJcbiAgICAgICFyZXN1bHQubWltZVR5cGUgfHxcclxuICAgICAgQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKTtcclxuXHJcbiAgICBpZiAoKGZpbmFsRm9ybXNbcmVzdWx0Lm1pbWVUeXBlXSAmJiAhc2hvdWxkSW5saW5lSHRtbGlmeSkgfHwgaXNQYXNzdGhyb3VnaCkge1xyXG4gICAgICAvLyBHb3Qgc29tZXRoaW5nIHdlIGNhbiB1c2UgaW4tYnJvd3NlciwgbGV0J3MgcmV0dXJuIGl0XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlc3VsdCwge2RlcGVuZGVudEZpbGVzfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkKGBSZWN1cnNpdmVseSBjb21waWxpbmcgcmVzdWx0IG9mICR7ZmlsZVBhdGh9IHdpdGggbm9uLWZpbmFsIE1JTUUgdHlwZSAke3Jlc3VsdC5taW1lVHlwZX0sIGlucHV0IHdhcyAke2lucHV0TWltZVR5cGV9YCk7XHJcblxyXG4gICAgICBoYXNoSW5mbyA9IE9iamVjdC5hc3NpZ24oeyBzb3VyY2VDb2RlOiByZXN1bHQuY29kZSwgbWltZVR5cGU6IHJlc3VsdC5taW1lVHlwZSB9LCBoYXNoSW5mbyk7XHJcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3Jlc3VsdC5taW1lVHlwZSB8fCAnX19sb2xub3RoZXJlJ107XHJcblxyXG4gICAgICBpZiAoIWNvbXBpbGVyKSB7XHJcbiAgICAgICAgZChgUmVjdXJzaXZlIGNvbXBpbGUgZmFpbGVkIC0gaW50ZXJtZWRpYXRlIHJlc3VsdDogJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfWApO1xyXG5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBpbGluZyAke2ZpbGVQYXRofSByZXN1bHRlZCBpbiBhIE1JTUUgdHlwZSBvZiAke3Jlc3VsdC5taW1lVHlwZX0sIHdoaWNoIHdlIGRvbid0IGtub3cgaG93IHRvIGhhbmRsZWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb21waWxlVW5jYWNoZWQoXHJcbiAgICAgICAgYCR7ZmlsZVBhdGh9LiR7bWltZVR5cGVzLmV4dGVuc2lvbihyZXN1bHQubWltZVR5cGUgfHwgJ3R4dCcpfWAsXHJcbiAgICAgICAgaGFzaEluZm8sIGNvbXBpbGVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZS1jYWNoZXMgYW4gZW50aXJlIGRpcmVjdG9yeSBvZiBmaWxlcyByZWN1cnNpdmVseS4gVXN1YWxseSB1c2VkIGZvclxyXG4gICAqIGJ1aWxkaW5nIGN1c3RvbSBjb21waWxlciB0b29saW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSByb290RGlyZWN0b3J5ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSB0byBjb21waWxlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gc2hvdWxkQ29tcGlsZSAob3B0aW9uYWwpICBBIEZ1bmN0aW9uIHdoaWNoIGFsbG93cyB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZXIgdG8gZGlzYWJsZSBjb21waWxpbmcgY2VydGFpbiBmaWxlcy5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCB0YWtlcyBhIGZ1bGx5LXF1YWxpZmllZCBwYXRoIHRvIGEgZmlsZSxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgc2hvdWxkIHJldHVybiBhIEJvb2xlYW4uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgQ29tcGxldGlvbi5cclxuICAgKi9cclxuICBhc3luYyBjb21waWxlQWxsKHJvb3REaXJlY3RvcnksIHNob3VsZENvbXBpbGU9bnVsbCkge1xyXG4gICAgbGV0IHNob3VsZCA9IHNob3VsZENvbXBpbGUgfHwgZnVuY3Rpb24oKSB7cmV0dXJuIHRydWU7fTtcclxuXHJcbiAgICBhd2FpdCBmb3JBbGxGaWxlcyhyb290RGlyZWN0b3J5LCAoZikgPT4ge1xyXG4gICAgICBpZiAoIXNob3VsZChmKSkgcmV0dXJuO1xyXG5cclxuICAgICAgZChgQ29tcGlsaW5nICR7Zn1gKTtcclxuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZShmLCB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBsaXN0ZW5Ub0NvbXBpbGVFdmVudHMoKSB7XHJcbiAgICByZXR1cm4gbGlzdGVuKCdlbGVjdHJvbi1jb21waWxlLWNvbXBpbGVkLWZpbGUnKS5tYXAoKFt4XSkgPT4geCk7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIFN5bmMgTWV0aG9kc1xyXG4gICAqL1xyXG5cclxuICBjb21waWxlU3luYyhmaWxlUGF0aCkge1xyXG4gICAgcmV0dXJuICh0aGlzLnJlYWRPbmx5TW9kZSA/IHRoaXMuY29tcGlsZVJlYWRPbmx5U3luYyhmaWxlUGF0aCkgOiB0aGlzLmZ1bGxDb21waWxlU3luYyhmaWxlUGF0aCkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb25TeW5jKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgZmFsbGJhY2tDb21waWxlcj1udWxsKSB7XHJcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IGZzLnJlYWRGaWxlU3luYyh0YXJnZXQpO1xyXG4gICAgbGV0IGluZm8gPSBKU09OLnBhcnNlKHpsaWIuZ3VuemlwU3luYyhidWYpKTtcclxuXHJcbiAgICBsZXQgZmlsZUNoYW5nZUNhY2hlID0gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoaW5mby5maWxlQ2hhbmdlQ2FjaGUsIGFwcFJvb3QsIHRydWUpO1xyXG5cclxuICAgIGxldCBjb21waWxlcnMgPSBPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycykucmVkdWNlKChhY2MsIHgpID0+IHtcclxuICAgICAgbGV0IGN1ciA9IGluZm8uY29tcGlsZXJzW3hdO1xyXG4gICAgICBhY2NbeF0gPSBuZXcgUmVhZE9ubHlDb21waWxlcihjdXIubmFtZSwgY3VyLmNvbXBpbGVyVmVyc2lvbiwgY3VyLmNvbXBpbGVyT3B0aW9ucywgY3VyLmlucHV0TWltZVR5cGVzKTtcclxuXHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB7fSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnMsIGZpbGVDaGFuZ2VDYWNoZSwgdHJ1ZSwgZmFsbGJhY2tDb21waWxlcik7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb25TeW5jKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgY29tcGlsZXJzQnlNaW1lVHlwZSwgZmFsbGJhY2tDb21waWxlcj1udWxsKSB7XHJcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IGZzLnJlYWRGaWxlU3luYyh0YXJnZXQpO1xyXG4gICAgbGV0IGluZm8gPSBKU09OLnBhcnNlKHpsaWIuZ3VuemlwU3luYyhidWYpKTtcclxuXHJcbiAgICBsZXQgZmlsZUNoYW5nZUNhY2hlID0gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoaW5mby5maWxlQ2hhbmdlQ2FjaGUsIGFwcFJvb3QsIGZhbHNlKTtcclxuXHJcbiAgICBPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycykuZm9yRWFjaCgoeCkgPT4ge1xyXG4gICAgICBsZXQgY3VyID0gaW5mby5jb21waWxlcnNbeF07XHJcbiAgICAgIGNvbXBpbGVyc0J5TWltZVR5cGVbeF0uY29tcGlsZXJPcHRpb25zID0gY3VyLmNvbXBpbGVyT3B0aW9ucztcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBuZXcgQ29tcGlsZXJIb3N0KHJvb3RDYWNoZURpciwgY29tcGlsZXJzQnlNaW1lVHlwZSwgZmlsZUNoYW5nZUNhY2hlLCBmYWxzZSwgZmFsbGJhY2tDb21waWxlcik7XHJcbiAgfVxyXG5cclxuICBzYXZlQ29uZmlndXJhdGlvblN5bmMoKSB7XHJcbiAgICBsZXQgc2VyaWFsaXplZENvbXBpbGVyT3B0cyA9IE9iamVjdC5rZXlzKHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZSkucmVkdWNlKChhY2MsIHgpID0+IHtcclxuICAgICAgbGV0IGNvbXBpbGVyID0gdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3hdO1xyXG4gICAgICBsZXQgS2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29tcGlsZXIpLmNvbnN0cnVjdG9yO1xyXG5cclxuICAgICAgbGV0IHZhbCA9IHtcclxuICAgICAgICBuYW1lOiBLbGFzcy5uYW1lLFxyXG4gICAgICAgIGlucHV0TWltZVR5cGVzOiBLbGFzcy5nZXRJbnB1dE1pbWVUeXBlcygpLFxyXG4gICAgICAgIGNvbXBpbGVyT3B0aW9uczogY29tcGlsZXIuY29tcGlsZXJPcHRpb25zLFxyXG4gICAgICAgIGNvbXBpbGVyVmVyc2lvbjogY29tcGlsZXIuZ2V0Q29tcGlsZXJWZXJzaW9uKClcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGFjY1t4XSA9IHZhbDtcclxuICAgICAgcmV0dXJuIGFjYztcclxuICAgIH0sIHt9KTtcclxuXHJcbiAgICBsZXQgaW5mbyA9IHtcclxuICAgICAgZmlsZUNoYW5nZUNhY2hlOiB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRTYXZlZERhdGEoKSxcclxuICAgICAgY29tcGlsZXJzOiBzZXJpYWxpemVkQ29tcGlsZXJPcHRzXHJcbiAgICB9O1xyXG5cclxuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4odGhpcy5yb290Q2FjaGVEaXIsICdjb21waWxlci1pbmZvLmpzb24uZ3onKTtcclxuICAgIGxldCBidWYgPSB6bGliLmd6aXBTeW5jKG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoaW5mbykpKTtcclxuICAgIGZzLndyaXRlRmlsZVN5bmModGFyZ2V0LCBidWYpO1xyXG4gIH1cclxuXHJcbiAgY29tcGlsZVJlYWRPbmx5U3luYyhmaWxlUGF0aCkge1xyXG4gICAgLy8gV2UgZ3VhcmFudGVlIHRoYXQgbm9kZV9tb2R1bGVzIGFyZSBhbHdheXMgc2hpcHBlZCBkaXJlY3RseVxyXG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcclxuICAgIGlmIChGaWxlQ2hhbmdlZENhY2hlLmlzSW5Ob2RlTW9kdWxlcyhmaWxlUGF0aCkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBtaW1lVHlwZTogdHlwZSB8fCAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXHJcbiAgICAgICAgY29kZTogZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGhhc2hJbmZvID0gdGhpcy5maWxlQ2hhbmdlQ2FjaGUuZ2V0SGFzaEZvclBhdGhTeW5jKGZpbGVQYXRoKTtcclxuXHJcbiAgICAvLyBXZSBndWFyYW50ZWUgdGhhdCBub2RlX21vZHVsZXMgYXJlIGFsd2F5cyBzaGlwcGVkIGRpcmVjdGx5XHJcbiAgICBpZiAoaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbWltZVR5cGU6IHR5cGUsXHJcbiAgICAgICAgY29kZTogaGFzaEluZm8uc291cmNlQ29kZSB8fCBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4JylcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOQjogSGVyZSwgd2UncmUgYmFzaWNhbGx5IG9ubHkgdXNpbmcgdGhlIGNvbXBpbGVyIGhlcmUgdG8gZmluZFxyXG4gICAgLy8gdGhlIGFwcHJvcHJpYXRlIENvbXBpbGVDYWNoZVxyXG4gICAgbGV0IGNvbXBpbGVyID0gQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSA/XHJcbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcclxuICAgICAgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3R5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xyXG5cclxuICAgIC8vIE5COiBXZSBkb24ndCBwdXQgdGhpcyBpbnRvIHNob3VsZFBhc3N0aHJvdWdoIGJlY2F1c2UgSW5saW5lIEhUTUxcclxuICAgIC8vIGNvbXBpbGVyIGlzIHRlY2huaWNhbGx5IG9mIHR5cGUgZmluYWxGb3JtcyAoaS5lLiBhIGJyb3dzZXIgY2FuXHJcbiAgICAvLyBuYXRpdmVseSBoYW5kbGUgdGhpcyBjb250ZW50KSwgeWV0IGl0cyBjb21waWxlciBpc1xyXG4gICAgLy8gSW5saW5lSHRtbENvbXBpbGVyLiBIb3dldmVyLCB3ZSBzdGlsbCB3YW50IHRvIGNhdGNoIHN0YW5kYXJkIENTUyBmaWxlc1xyXG4gICAgLy8gd2hpY2ggd2lsbCBiZSBwcm9jZXNzZWQgYnkgUGFzc3Rocm91Z2hDb21waWxlci5cclxuICAgIGlmIChmaW5hbEZvcm1zW3R5cGVdICYmICFjb21waWxlcikge1xyXG4gICAgICBjb21waWxlciA9IHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29tcGlsZXIpIHtcclxuICAgICAgY29tcGlsZXIgPSB0aGlzLmZhbGxiYWNrQ29tcGlsZXI7XHJcblxyXG4gICAgICBsZXQgeyBjb2RlLCBiaW5hcnlEYXRhLCBtaW1lVHlwZSB9ID0gY29tcGlsZXIuZ2V0U3luYyhmaWxlUGF0aCk7XHJcbiAgICAgIHJldHVybiB7IGNvZGU6IGNvZGUgfHwgYmluYXJ5RGF0YSwgbWltZVR5cGUgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FjaGUgPSB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycy5nZXQoY29tcGlsZXIpO1xyXG4gICAgbGV0IHtjb2RlLCBiaW5hcnlEYXRhLCBtaW1lVHlwZX0gPSBjYWNoZS5nZXRTeW5jKGZpbGVQYXRoKTtcclxuXHJcbiAgICBjb2RlID0gY29kZSB8fCBiaW5hcnlEYXRhO1xyXG4gICAgaWYgKCFjb2RlIHx8ICFtaW1lVHlwZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFza2VkIHRvIGNvbXBpbGUgJHtmaWxlUGF0aH0gaW4gcHJvZHVjdGlvbiwgaXMgdGhpcyBmaWxlIG5vdCBwcmVjb21waWxlZD9gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZSB9O1xyXG4gIH1cclxuXHJcbiAgZnVsbENvbXBpbGVTeW5jKGZpbGVQYXRoKSB7XHJcbiAgICBkKGBDb21waWxpbmcgJHtmaWxlUGF0aH1gKTtcclxuXHJcbiAgICBsZXQgaGFzaEluZm8gPSB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aFN5bmMoZmlsZVBhdGgpO1xyXG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcclxuXHJcbiAgICBzZW5kKCdlbGVjdHJvbi1jb21waWxlLWNvbXBpbGVkLWZpbGUnLCB7IGZpbGVQYXRoLCBtaW1lVHlwZTogdHlwZSB9KTtcclxuXHJcbiAgICBpZiAoaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzKSB7XHJcbiAgICAgIGxldCBjb2RlID0gaGFzaEluZm8uc291cmNlQ29kZSB8fCBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jyk7XHJcbiAgICAgIGNvZGUgPSBDb21waWxlckhvc3QuZml4Tm9kZU1vZHVsZXNTb3VyY2VNYXBwaW5nU3luYyhjb2RlLCBmaWxlUGF0aCwgdGhpcy5maWxlQ2hhbmdlQ2FjaGUuYXBwUm9vdCk7XHJcbiAgICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlOiB0eXBlIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNvbXBpbGVyID0gQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSA/XHJcbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcclxuICAgICAgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3R5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xyXG5cclxuICAgIGlmICghY29tcGlsZXIpIHtcclxuICAgICAgZChgRmFsbGluZyBiYWNrIHRvIHBhc3N0aHJvdWdoIGNvbXBpbGVyIGZvciAke2ZpbGVQYXRofWApO1xyXG4gICAgICBjb21waWxlciA9IHRoaXMuZmFsbGJhY2tDb21waWxlcjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNvbXBpbGVyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBhIGNvbXBpbGVyIGZvciAke2ZpbGVQYXRofWApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjYWNoZSA9IHRoaXMuY2FjaGVzRm9yQ29tcGlsZXJzLmdldChjb21waWxlcik7XHJcbiAgICByZXR1cm4gY2FjaGUuZ2V0T3JGZXRjaFN5bmMoXHJcbiAgICAgIGZpbGVQYXRoLFxyXG4gICAgICAoZmlsZVBhdGgsIGhhc2hJbmZvKSA9PiB0aGlzLmNvbXBpbGVVbmNhY2hlZFN5bmMoZmlsZVBhdGgsIGhhc2hJbmZvLCBjb21waWxlcikpO1xyXG4gIH1cclxuXHJcbiAgY29tcGlsZVVuY2FjaGVkU3luYyhmaWxlUGF0aCwgaGFzaEluZm8sIGNvbXBpbGVyKSB7XHJcbiAgICBsZXQgaW5wdXRNaW1lVHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xyXG5cclxuICAgIGlmIChoYXNoSW5mby5pc0ZpbGVCaW5hcnkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBiaW5hcnlEYXRhOiBoYXNoSW5mby5iaW5hcnlEYXRhIHx8IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCksXHJcbiAgICAgICAgbWltZVR5cGU6IGlucHV0TWltZVR5cGUsXHJcbiAgICAgICAgZGVwZW5kZW50RmlsZXM6IFtdXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGN0eCA9IHt9O1xyXG4gICAgbGV0IGNvZGUgPSBoYXNoSW5mby5zb3VyY2VDb2RlIHx8IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKTtcclxuXHJcbiAgICBpZiAoIShjb21waWxlci5zaG91bGRDb21waWxlRmlsZVN5bmMoY29kZSwgY3R4KSkpIHtcclxuICAgICAgZChgQ29tcGlsZXIgcmV0dXJuZWQgZmFsc2UgZm9yIHNob3VsZENvbXBpbGVGaWxlOiAke2ZpbGVQYXRofWApO1xyXG4gICAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZTogbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCksIGRlcGVuZGVudEZpbGVzOiBbXSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBkZXBlbmRlbnRGaWxlcyA9IGNvbXBpbGVyLmRldGVybWluZURlcGVuZGVudEZpbGVzU3luYyhjb2RlLCBmaWxlUGF0aCwgY3R4KTtcclxuXHJcbiAgICBsZXQgcmVzdWx0ID0gY29tcGlsZXIuY29tcGlsZVN5bmMoY29kZSwgZmlsZVBhdGgsIGN0eCk7XHJcblxyXG4gICAgbGV0IHNob3VsZElubGluZUh0bWxpZnkgPVxyXG4gICAgICBpbnB1dE1pbWVUeXBlICE9PSAndGV4dC9odG1sJyAmJlxyXG4gICAgICByZXN1bHQubWltZVR5cGUgPT09ICd0ZXh0L2h0bWwnO1xyXG5cclxuICAgIGxldCBpc1Bhc3N0aHJvdWdoID1cclxuICAgICAgcmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9wbGFpbicgfHxcclxuICAgICAgIXJlc3VsdC5taW1lVHlwZSB8fFxyXG4gICAgICBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pO1xyXG5cclxuICAgIGlmICgoZmluYWxGb3Jtc1tyZXN1bHQubWltZVR5cGVdICYmICFzaG91bGRJbmxpbmVIdG1saWZ5KSB8fCBpc1Bhc3N0aHJvdWdoKSB7XHJcbiAgICAgIC8vIEdvdCBzb21ldGhpbmcgd2UgY2FuIHVzZSBpbi1icm93c2VyLCBsZXQncyByZXR1cm4gaXRcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7ZGVwZW5kZW50RmlsZXN9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGQoYFJlY3Vyc2l2ZWx5IGNvbXBpbGluZyByZXN1bHQgb2YgJHtmaWxlUGF0aH0gd2l0aCBub24tZmluYWwgTUlNRSB0eXBlICR7cmVzdWx0Lm1pbWVUeXBlfSwgaW5wdXQgd2FzICR7aW5wdXRNaW1lVHlwZX1gKTtcclxuXHJcbiAgICAgIGhhc2hJbmZvID0gT2JqZWN0LmFzc2lnbih7IHNvdXJjZUNvZGU6IHJlc3VsdC5jb2RlLCBtaW1lVHlwZTogcmVzdWx0Lm1pbWVUeXBlIH0sIGhhc2hJbmZvKTtcclxuICAgICAgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbcmVzdWx0Lm1pbWVUeXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcclxuXHJcbiAgICAgIGlmICghY29tcGlsZXIpIHtcclxuICAgICAgICBkKGBSZWN1cnNpdmUgY29tcGlsZSBmYWlsZWQgLSBpbnRlcm1lZGlhdGUgcmVzdWx0OiAke0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9YCk7XHJcblxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcGlsaW5nICR7ZmlsZVBhdGh9IHJlc3VsdGVkIGluIGEgTUlNRSB0eXBlIG9mICR7cmVzdWx0Lm1pbWVUeXBlfSwgd2hpY2ggd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVVbmNhY2hlZFN5bmMoXHJcbiAgICAgICAgYCR7ZmlsZVBhdGh9LiR7bWltZVR5cGVzLmV4dGVuc2lvbihyZXN1bHQubWltZVR5cGUgfHwgJ3R4dCcpfWAsXHJcbiAgICAgICAgaGFzaEluZm8sIGNvbXBpbGVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbXBpbGVBbGxTeW5jKHJvb3REaXJlY3RvcnksIHNob3VsZENvbXBpbGU9bnVsbCkge1xyXG4gICAgbGV0IHNob3VsZCA9IHNob3VsZENvbXBpbGUgfHwgZnVuY3Rpb24oKSB7cmV0dXJuIHRydWU7fTtcclxuXHJcbiAgICBmb3JBbGxGaWxlc1N5bmMocm9vdERpcmVjdG9yeSwgKGYpID0+IHtcclxuICAgICAgaWYgKCFzaG91bGQoZikpIHJldHVybjtcclxuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZVN5bmMoZiwgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBPdGhlciBzdHVmZlxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcGFzc3Rocm91Z2ggY29tcGlsZXJcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbJ3RleHQvcGxhaW4nXTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGV2ZW4gdHJ5IHRvIGNvbXBpbGUgdGhlIGNvbnRlbnQuIE5vdGUgdGhhdCBpblxyXG4gICAqIHNvbWUgY2FzZXMsIGNvbnRlbnQgd2lsbCBzdGlsbCBiZSBpbiBjYWNoZSBldmVuIGlmIHRoaXMgcmV0dXJucyB0cnVlLCBhbmRcclxuICAgKiBpbiBvdGhlciBjYXNlcyAoaXNJbk5vZGVNb2R1bGVzKSwgd2UnbGwga25vdyBleHBsaWNpdGx5IHRvIG5vdCBldmVuIGJvdGhlclxyXG4gICAqIGxvb2tpbmcgaW4gdGhlIGNhY2hlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pIHtcclxuICAgIHJldHVybiBoYXNoSW5mby5pc01pbmlmaWVkIHx8IGhhc2hJbmZvLmlzSW5Ob2RlTW9kdWxlcyB8fCBoYXNoSW5mby5oYXNTb3VyY2VNYXAgfHwgaGFzaEluZm8uaXNGaWxlQmluYXJ5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9vayBhdCB0aGUgY29kZSBvZiBhIG5vZGUgbW9kdWxlcyBhbmQgc2VlIHRoZSBzb3VyY2VNYXBwaW5nIHBhdGguXHJcbiAgICogSWYgdGhlcmUgaXMgYW55LCBjaGVjayB0aGUgcGF0aCBhbmQgdHJ5IHRvIGZpeCBpdCB3aXRoIGFuZFxyXG4gICAqIHJvb3QgcmVsYXRpdmUgcGF0aC5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBmaXhOb2RlTW9kdWxlc1NvdXJjZU1hcHBpbmcoc291cmNlQ29kZSwgc291cmNlUGF0aCwgYXBwUm9vdCkge1xyXG4gICAgbGV0IHJlZ2V4U291cmNlTWFwcGluZyA9IC9cXC9cXC8jLipzb3VyY2VNYXBwaW5nVVJMPSg/IWRhdGE6KShbXlwiJ10uKikvaTtcclxuICAgIGxldCBzb3VyY2VNYXBwaW5nQ2hlY2sgPSBzb3VyY2VDb2RlLm1hdGNoKHJlZ2V4U291cmNlTWFwcGluZyk7XHJcblxyXG4gICAgaWYgKHNvdXJjZU1hcHBpbmdDaGVjayAmJiBzb3VyY2VNYXBwaW5nQ2hlY2tbMV0gJiYgc291cmNlTWFwcGluZ0NoZWNrWzFdICE9PSAnJyl7XHJcbiAgICAgIGxldCBzb3VyY2VNYXBQYXRoID0gc291cmNlTWFwcGluZ0NoZWNrWzFdO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBwZnMuc3RhdChzb3VyY2VNYXBQYXRoKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBsZXQgbm9ybVJvb3QgPSBwYXRoLm5vcm1hbGl6ZShhcHBSb290KTtcclxuICAgICAgICBsZXQgYWJzUGF0aFRvTW9kdWxlID0gcGF0aC5kaXJuYW1lKHNvdXJjZVBhdGgucmVwbGFjZShub3JtUm9vdCwgJycpLnN1YnN0cmluZygxKSk7XHJcbiAgICAgICAgbGV0IG5ld01hcFBhdGggPSBwYXRoLmpvaW4oYWJzUGF0aFRvTW9kdWxlLCBzb3VyY2VNYXBQYXRoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZUNvZGUucmVwbGFjZShyZWdleFNvdXJjZU1hcHBpbmcsIGAvLyMgc291cmNlTWFwcGluZ1VSTD0ke25ld01hcFBhdGh9YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc291cmNlQ29kZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvb2sgYXQgdGhlIGNvZGUgb2YgYSBub2RlIG1vZHVsZXMgYW5kIHNlZSB0aGUgc291cmNlTWFwcGluZyBwYXRoLlxyXG4gICAqIElmIHRoZXJlIGlzIGFueSwgY2hlY2sgdGhlIHBhdGggYW5kIHRyeSB0byBmaXggaXQgd2l0aCBhbmRcclxuICAgKiByb290IHJlbGF0aXZlIHBhdGguXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgZml4Tm9kZU1vZHVsZXNTb3VyY2VNYXBwaW5nU3luYyhzb3VyY2VDb2RlLCBzb3VyY2VQYXRoLCBhcHBSb290KSB7XHJcbiAgICBsZXQgcmVnZXhTb3VyY2VNYXBwaW5nID0gL1xcL1xcLyMuKnNvdXJjZU1hcHBpbmdVUkw9KD8hZGF0YTopKFteXCInXS4qKS9pO1xyXG4gICAgbGV0IHNvdXJjZU1hcHBpbmdDaGVjayA9IHNvdXJjZUNvZGUubWF0Y2gocmVnZXhTb3VyY2VNYXBwaW5nKTtcclxuXHJcbiAgICBpZiAoc291cmNlTWFwcGluZ0NoZWNrICYmIHNvdXJjZU1hcHBpbmdDaGVja1sxXSAmJiBzb3VyY2VNYXBwaW5nQ2hlY2tbMV0gIT09ICcnKXtcclxuICAgICAgbGV0IHNvdXJjZU1hcFBhdGggPSBzb3VyY2VNYXBwaW5nQ2hlY2tbMV07XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZzLnN0YXRTeW5jKHNvdXJjZU1hcFBhdGgpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGxldCBub3JtUm9vdCA9IHBhdGgubm9ybWFsaXplKGFwcFJvb3QpO1xyXG4gICAgICAgIGxldCBhYnNQYXRoVG9Nb2R1bGUgPSBwYXRoLmRpcm5hbWUoc291cmNlUGF0aC5yZXBsYWNlKG5vcm1Sb290LCAnJykuc3Vic3RyaW5nKDEpKTtcclxuICAgICAgICBsZXQgbmV3TWFwUGF0aCA9IHBhdGguam9pbihhYnNQYXRoVG9Nb2R1bGUsIHNvdXJjZU1hcFBhdGgpO1xyXG5cclxuICAgICAgICByZXR1cm4gc291cmNlQ29kZS5yZXBsYWNlKHJlZ2V4U291cmNlTWFwcGluZywgYC8vIyBzb3VyY2VNYXBwaW5nVVJMPSR7bmV3TWFwUGF0aH1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzb3VyY2VDb2RlO1xyXG4gIH1cclxufVxyXG4iXX0=