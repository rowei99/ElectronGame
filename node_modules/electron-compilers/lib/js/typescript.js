'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _compilerBase = require('../compiler-base');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _jsStringEscape = require('js-string-escape');

var _jsStringEscape2 = _interopRequireDefault(_jsStringEscape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inputMimeTypes = ['text/typescript', 'text/tsx'];
const d = require('debug')('electron-compile:typescript-compiler');

let ts = null;

const builtinKeys = ['hotModuleReload'];

/**
 * @access private
 */
class TypeScriptCompiler extends _compilerBase.SimpleCompilerBase {
  constructor() {
    super();

    this.outMimeType = 'application/javascript';
    this.compilerOptions = {
      inlineSourceMap: true,
      inlineSources: true
    };
  }

  static getInputMimeTypes() {
    return inputMimeTypes;
  }

  _getParsedConfigOptions(tsCompiler) {
    let parsedConfig = this.parsedConfig;

    if (!parsedConfig) {
      let opts = Object.assign({}, this.compilerOptions);
      let builtinOpts = {};
      builtinKeys.forEach(k => {
        if (k in this.compilerOptions) {
          delete opts[k];
          builtinOpts[k] = this.compilerOptions[k];
        }
      });

      const results = tsCompiler.convertCompilerOptionsFromJson(opts);

      if (results.errors && results.errors.length) {
        throw new Error(JSON.stringify(results.errors));
      }

      parsedConfig = this.parsedConfig = { typescriptOpts: results.options, builtinOpts };
    }

    return parsedConfig;
  }

  compileSync(sourceCode, filePath) {
    ts = ts || require('typescript');
    const options = this._getParsedConfigOptions(ts);

    const isTsx = filePath.match(/\.tsx$/i);
    const transpileOptions = {
      compilerOptions: options.typescriptOpts,
      fileName: filePath.match(/\.(ts|tsx)$/i) ? _path2.default.basename(filePath) : null
    };

    if (isTsx && options.builtinOpts.hotModuleReload !== false) {
      sourceCode = this.addHotModuleLoadingRegistration(sourceCode, filePath, this.getExportsForFile(filePath, options.typescriptOpts));
    }

    const output = ts.transpileModule(sourceCode, transpileOptions);
    const sourceMaps = output.sourceMapText ? output.sourceMapText : null;

    d(JSON.stringify(output.diagnostics));

    return {
      code: output.outputText,
      mimeType: this.outMimeType,
      sourceMaps
    };
  }

  addHotModuleLoadingRegistration(sourceCode, fileName, exports) {
    if (exports.length < 1) return sourceCode;

    let registrations = exports.map(x => `__REACT_HOT_LOADER__.register(${ x }, "${ x }", __FILENAME__);\n`);

    let tmpl = `
${ sourceCode }

if (typeof __REACT_HOT_LOADER__ !== 'undefined') {
  const __FILENAME__ = "${ (0, _jsStringEscape2.default)(fileName) }";
  ${ registrations }
}`;

    return tmpl;
  }

  getExportsForFile(fileName, tsOptions) {
    let pg = ts.createProgram([fileName], tsOptions);
    let c = pg.getTypeChecker();
    let ret = [];

    // Walk the tree to search for classes
    let visit = node => {
      if (!this.isNodeExported(node)) return;

      if (node.kind === ts.SyntaxKind.ClassDeclaration || node.kind === ts.SyntaxKind.FunctionDeclaration) {
        ret.push(c.getSymbolAtLocation(node.name).getName());
      }
    };

    let filePathWithForwardSlashes = fileName.replace(/[\\]/g, '/');
    for (const sourceFile of pg.getSourceFiles()) {
      if (sourceFile.fileName !== filePathWithForwardSlashes) {
        continue;
      }

      ts.forEachChild(sourceFile, visit);
    }

    return ret;
  }

  isNodeExported(node) {
    return (node.flags & ts.NodeFlags.Export) !== 0 || node.parent && node.parent.kind === ts.SyntaxKind.SourceFile;
  }

  getCompilerVersion() {
    return require('typescript/package.json').version;
  }
}
exports.default = TypeScriptCompiler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9qcy90eXBlc2NyaXB0LmpzIl0sIm5hbWVzIjpbImlucHV0TWltZVR5cGVzIiwiZCIsInJlcXVpcmUiLCJ0cyIsImJ1aWx0aW5LZXlzIiwiVHlwZVNjcmlwdENvbXBpbGVyIiwiY29uc3RydWN0b3IiLCJvdXRNaW1lVHlwZSIsImNvbXBpbGVyT3B0aW9ucyIsImlubGluZVNvdXJjZU1hcCIsImlubGluZVNvdXJjZXMiLCJnZXRJbnB1dE1pbWVUeXBlcyIsIl9nZXRQYXJzZWRDb25maWdPcHRpb25zIiwidHNDb21waWxlciIsInBhcnNlZENvbmZpZyIsIm9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJidWlsdGluT3B0cyIsImZvckVhY2giLCJrIiwicmVzdWx0cyIsImNvbnZlcnRDb21waWxlck9wdGlvbnNGcm9tSnNvbiIsImVycm9ycyIsImxlbmd0aCIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInR5cGVzY3JpcHRPcHRzIiwib3B0aW9ucyIsImNvbXBpbGVTeW5jIiwic291cmNlQ29kZSIsImZpbGVQYXRoIiwiaXNUc3giLCJtYXRjaCIsInRyYW5zcGlsZU9wdGlvbnMiLCJmaWxlTmFtZSIsImJhc2VuYW1lIiwiaG90TW9kdWxlUmVsb2FkIiwiYWRkSG90TW9kdWxlTG9hZGluZ1JlZ2lzdHJhdGlvbiIsImdldEV4cG9ydHNGb3JGaWxlIiwib3V0cHV0IiwidHJhbnNwaWxlTW9kdWxlIiwic291cmNlTWFwcyIsInNvdXJjZU1hcFRleHQiLCJkaWFnbm9zdGljcyIsImNvZGUiLCJvdXRwdXRUZXh0IiwibWltZVR5cGUiLCJleHBvcnRzIiwicmVnaXN0cmF0aW9ucyIsIm1hcCIsIngiLCJ0bXBsIiwidHNPcHRpb25zIiwicGciLCJjcmVhdGVQcm9ncmFtIiwiYyIsImdldFR5cGVDaGVja2VyIiwicmV0IiwidmlzaXQiLCJub2RlIiwiaXNOb2RlRXhwb3J0ZWQiLCJraW5kIiwiU3ludGF4S2luZCIsIkNsYXNzRGVjbGFyYXRpb24iLCJGdW5jdGlvbkRlY2xhcmF0aW9uIiwicHVzaCIsImdldFN5bWJvbEF0TG9jYXRpb24iLCJuYW1lIiwiZ2V0TmFtZSIsImZpbGVQYXRoV2l0aEZvcndhcmRTbGFzaGVzIiwicmVwbGFjZSIsInNvdXJjZUZpbGUiLCJnZXRTb3VyY2VGaWxlcyIsImZvckVhY2hDaGlsZCIsImZsYWdzIiwiTm9kZUZsYWdzIiwiRXhwb3J0IiwicGFyZW50IiwiU291cmNlRmlsZSIsImdldENvbXBpbGVyVmVyc2lvbiIsInZlcnNpb24iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLE1BQU1BLGlCQUFpQixDQUFDLGlCQUFELEVBQW9CLFVBQXBCLENBQXZCO0FBQ0EsTUFBTUMsSUFBSUMsUUFBUSxPQUFSLEVBQWlCLHNDQUFqQixDQUFWOztBQUVBLElBQUlDLEtBQUssSUFBVDs7QUFFQSxNQUFNQyxjQUFjLENBQUMsaUJBQUQsQ0FBcEI7O0FBRUE7OztBQUdlLE1BQU1DLGtCQUFOLDBDQUFvRDtBQUNqRUMsZ0JBQWM7QUFDWjs7QUFFQSxTQUFLQyxXQUFMLEdBQW1CLHdCQUFuQjtBQUNBLFNBQUtDLGVBQUwsR0FBdUI7QUFDckJDLHVCQUFpQixJQURJO0FBRXJCQyxxQkFBZTtBQUZNLEtBQXZCO0FBSUQ7O0FBRUQsU0FBT0MsaUJBQVAsR0FBMkI7QUFDekIsV0FBT1gsY0FBUDtBQUNEOztBQUVEWSwwQkFBd0JDLFVBQXhCLEVBQW9DO0FBQ2xDLFFBQUlDLGVBQWUsS0FBS0EsWUFBeEI7O0FBRUEsUUFBSSxDQUFDQSxZQUFMLEVBQW1CO0FBQ2pCLFVBQUlDLE9BQU9DLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLEtBQUtULGVBQXZCLENBQVg7QUFDQSxVQUFJVSxjQUFjLEVBQWxCO0FBQ0FkLGtCQUFZZSxPQUFaLENBQXFCQyxDQUFELElBQU87QUFDekIsWUFBSUEsS0FBSyxLQUFLWixlQUFkLEVBQStCO0FBQzdCLGlCQUFPTyxLQUFLSyxDQUFMLENBQVA7QUFDQUYsc0JBQVlFLENB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QUFDRDtBQUNGLEtBTkQ7O0FBUUEsUUFBSUMsNkJBQTZCbkMsU0FBU29DLE9BQVQsQ0FBaUIsT0FBakIsRUFBMEIsR0FBMUIsQ0FBakM7QUFDQSxTQUFLLE1BQU1DLFVBQVgsSUFBeUJsQixHQUFHbUIsY0FBSCxFQUF6QixFQUE4QztBQUM1QyxVQUFJRCxXQUFXckMsUUFBWCxLQUF3Qm1DLDBCQUE1QixFQUF3RDtBQUN0RDtBQUNEOztBQUVEcEUsU0FBR3dFLFlBQUgsQ0FBZ0JGLFVBQWhCLEVBQTRCYixLQUE1QjtBQUNEOztBQUVELFdBQU9ELEdBQVA7QUFDRDs7QUFFREcsaUJBQWVELElBQWYsRUFBcUI7QUFDbkIsV0FBTyxDQUFDQSxLQUFLZSxLQUFMLEdBQWF6RSxHQUFHMEUsU0FBSCxDQUFhQyxNQUEzQixNQUF1QyxDQUF2QyxJQUE2Q2pCLEtBQUtrQixNQUFMLElBQWVsQixLQUFLa0IsTUFBTCxDQUFZaEIsSUFBWixLQUFxQjVELEdBQUc2RCxVQUFILENBQWNnQixVQUF0RztBQUNEOztBQUVEQyx1QkFBcUI7QUFDbkIsV0FBTy9FLFFBQVEseUJBQVIsRUFBbUNnRixPQUExQztBQUNEO0FBcEhnRTtrQkFBOUM3RSxrQiIsImZpbGUiOiJ0eXBlc2NyaXB0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtTaW1wbGVDb21waWxlckJhc2V9IGZyb20gJy4uL2NvbXBpbGVyLWJhc2UnO1xyXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0IGpzRXNjYXBlIGZyb20gJ2pzLXN0cmluZy1lc2NhcGUnO1xyXG5cclxuY29uc3QgaW5wdXRNaW1lVHlwZXMgPSBbJ3RleHQvdHlwZXNjcmlwdCcsICd0ZXh0L3RzeCddO1xyXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWcnKSgnZWxlY3Ryb24tY29tcGlsZTp0eXBlc2NyaXB0LWNvbXBpbGVyJyk7XHJcblxyXG5sZXQgdHMgPSBudWxsO1xyXG5cclxuY29uc3QgYnVpbHRpbktleXMgPSBbJ2hvdE1vZHVsZVJlbG9hZCddO1xyXG5cclxuLyoqXHJcbiAqIEBhY2Nlc3MgcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHlwZVNjcmlwdENvbXBpbGVyIGV4dGVuZHMgU2ltcGxlQ29tcGlsZXJCYXNlIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5vdXRNaW1lVHlwZSA9ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JztcclxuICAgIHRoaXMuY29tcGlsZXJPcHRpb25zID0ge1xyXG4gICAgICBpbmxpbmVTb3VyY2VNYXA6IHRydWUsXHJcbiAgICAgIGlubGluZVNvdXJjZXM6IHRydWVcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0SW5wdXRNaW1lVHlwZXMoKSB7XHJcbiAgICByZXR1cm4gaW5wdXRNaW1lVHlwZXM7XHJcbiAgfVxyXG5cclxuICBfZ2V0UGFyc2VkQ29uZmlnT3B0aW9ucyh0c0NvbXBpbGVyKSB7XHJcbiAgICBsZXQgcGFyc2VkQ29uZmlnID0gdGhpcy5wYXJzZWRDb25maWc7XHJcblxyXG4gICAgaWYgKCFwYXJzZWRDb25maWcpIHtcclxuICAgICAgbGV0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbXBpbGVyT3B0aW9ucyk7XHJcbiAgICAgIGxldCBidWlsdGluT3B0cyA9IHt9O1xyXG4gICAgICBidWlsdGluS2V5cy5mb3JFYWNoKChrKSA9PiB7XHJcbiAgICAgICAgaWYgKGsgaW4gdGhpcy5jb21waWxlck9wdGlvbnMpIHtcclxuICAgICAgICAgIGRlbGV0ZSBvcHRzW2tdO1xyXG4gICAgICAgICAgYnVpbHRpbk9wdHNba10gPSB0aGlzLmNvbXBpbGVyT3B0aW9uc1trXTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0cyA9IHRzQ29tcGlsZXIuY29udmVydENvbXBpbGVyT3B0aW9uc0Zyb21Kc29uKG9wdHMpO1xyXG5cclxuICAgICAgaWYgKHJlc3VsdHMuZXJyb3JzICYmIHJlc3VsdHMuZXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShyZXN1bHRzLmVycm9ycykpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwYXJzZWRDb25maWcgPSB0aGlzLnBhcnNlZENvbmZpZyA9IHsgdHlwZXNjcmlwdE9wdHM6IHJlc3VsdHMub3B0aW9ucywgYnVpbHRpbk9wdHMgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyc2VkQ29uZmlnO1xyXG4gIH1cclxuXHJcbiAgY29tcGlsZVN5bmMoc291cmNlQ29kZSwgZmlsZVBhdGgpIHtcclxuICAgIHRzID0gdHMgfHwgcmVxdWlyZSgndHlwZXNjcmlwdCcpO1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldFBhcnNlZENvbmZpZ09wdGlvbnModHMpO1xyXG5cclxuICAgIGNvbnN0IGlzVHN4ID0gZmlsZVBhdGgubWF0Y2goL1xcLnRzeCQvaSk7XHJcbiAgICBjb25zdCB0cmFuc3BpbGVPcHRpb25zID0ge1xyXG4gICAgICBjb21waWxlck9wdGlvbnM6IG9wdGlvbnMudHlwZXNjcmlwdE9wdHMsXHJcbiAgICAgIGZpbGVOYW1lOiBmaWxlUGF0aC5tYXRjaCgvXFwuKHRzfHRzeCkkL2kpID8gcGF0aC5iYXNlbmFtZShmaWxlUGF0aCkgOiBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpc1RzeCAmJiBvcHRpb25zLmJ1aWx0aW5PcHRzLmhvdE1vZHVsZVJlbG9hZCAhPT0gZmFsc2UpIHtcclxuICAgICAgc291cmNlQ29kZSA9IHRoaXMuYWRkSG90TW9kdWxlTG9hZGluZ1JlZ2lzdHJhdGlvbihzb3VyY2VDb2RlLCBmaWxlUGF0aCwgdGhpcy5nZXRFeHBvcnRzRm9yRmlsZShmaWxlUGF0aCwgb3B0aW9ucy50eXBlc2NyaXB0T3B0cykpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG91dHB1dCA9IHRzLnRyYW5zcGlsZU1vZHVsZShzb3VyY2VDb2RlLCB0cmFuc3BpbGVPcHRpb25zKTtcclxuICAgIGNvbnN0IHNvdXJjZU1hcHMgPSBvdXRwdXQuc291cmNlTWFwVGV4dCA/IG91dHB1dC5zb3VyY2VNYXBUZXh0IDogbnVsbDtcclxuXHJcbiAgICBkKEpTT04uc3RyaW5naWZ5KG91dHB1dC5kaWFnbm9zdGljcykpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvZGU6IG91dHB1dC5vdXRwdXRUZXh0LFxyXG4gICAgICBtaW1lVHlwZTogdGhpcy5vdXRNaW1lVHlwZSxcclxuICAgICAgc291cmNlTWFwc1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGFkZEhvdE1vZHVsZUxvYWRpbmdSZWdpc3RyYXRpb24oc291cmNlQ29kZSwgZmlsZU5hbWUsIGV4cG9ydHMpIHtcclxuICAgIGlmIChleHBvcnRzLmxlbmd0aCA8IDEpIHJldHVybiBzb3VyY2VDb2RlO1xyXG5cclxuICAgIGxldCByZWdpc3RyYXRpb25zID0gZXhwb3J0cy5tYXAoeCA9PiBcclxuICAgICAgYF9fUkVBQ1RfSE9UX0xPQURFUl9fLnJlZ2lzdGVyKCR7eH0sIFwiJHt4fVwiLCBfX0ZJTEVOQU1FX18pO1xcbmBcclxuICAgICk7XHJcblxyXG4gICAgbGV0IHRtcGwgPSBgXHJcbiR7c291cmNlQ29kZX1cclxuXHJcbmlmICh0eXBlb2YgX19SRUFDVF9IT1RfTE9BREVSX18gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgY29uc3QgX19GSUxFTkFNRV9fID0gXCIke2pzRXNjYXBlKGZpbGVOYW1lKX1cIjtcclxuICAke3JlZ2lzdHJhdGlvbnN9XHJcbn1gO1xyXG5cclxuICAgIHJldHVybiB0bXBsO1xyXG4gIH1cclxuXHJcbiAgZ2V0RXhwb3J0c0ZvckZpbGUoZmlsZU5hbWUsIHRzT3B0aW9ucykge1xyXG4gICAgbGV0IHBnID0gdHMuY3JlYXRlUHJvZ3JhbShbZmlsZU5hbWVdLCB0c09wdGlvbnMpO1xyXG4gICAgbGV0IGMgPSBwZy5nZXRUeXBlQ2hlY2tlcigpO1xyXG4gICAgbGV0IHJldCA9IFtdO1xyXG5cclxuICAgIC8vIFdhbGsgdGhlIHRyZWUgdG8gc2VhcmNoIGZvciBjbGFzc2VzXHJcbiAgICBsZXQgdmlzaXQgPSAobm9kZSkgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuaXNOb2RlRXhwb3J0ZWQobm9kZSkpIHJldHVybjtcclxuICAgICAgXHJcbiAgICAgIGlmIChub2RlLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbiB8fCBub2RlLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuRnVuY3Rpb25EZWNsYXJhdGlvbikge1xyXG4gICAgICAgIHJldC5wdXNoKGMuZ2V0U3ltYm9sQXRMb2NhdGlvbihub2RlLm5hbWUpLmdldE5hbWUoKSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbGV0IGZpbGVQYXRoV2l0aEZvcndhcmRTbGFzaGVzID0gZmlsZU5hbWUucmVwbGFjZSgvW1xcXFxdL2csICcvJyk7XHJcbiAgICBmb3IgKGNvbnN0IHNvdXJjZUZpbGUgb2YgcGcuZ2V0U291cmNlRmlsZXMoKSkge1xyXG4gICAgICBpZiAoc291cmNlRmlsZS5maWxlTmFtZSAhPT0gZmlsZVBhdGhXaXRoRm9yd2FyZFNsYXNoZXMpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgdHMuZm9yRWFjaENoaWxkKHNvdXJjZUZpbGUsIHZpc2l0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH1cclxuXHJcbiAgaXNOb2RlRXhwb3J0ZWQobm9kZSkge1xyXG4gICAgcmV0dXJuIChub2RlLmZsYWdzICYgdHMuTm9kZUZsYWdzLkV4cG9ydCkgIT09IDAgfHwgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LmtpbmQgPT09IHRzLlN5bnRheEtpbmQuU291cmNlRmlsZSk7XHJcbiAgfVxyXG5cclxuICBnZXRDb21waWxlclZlcnNpb24oKSB7XHJcbiAgICByZXR1cm4gcmVxdWlyZSgndHlwZXNjcmlwdC9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xyXG4gIH1cclxufVxyXG4iXX0=