'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _compilerBase = require('../compiler-base');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const mimeTypes = ['text/jsx', 'application/javascript'];
let babel = null;

/**
 * @access private
 */
class BabelCompiler extends _compilerBase.SimpleCompilerBase {
  constructor() {
    super();
  }

  static getInputMimeTypes() {
    return mimeTypes;
  }

  // NB: This method exists to stop Babel from trying to load plugins from the
  // app's node_modules directory, which in a production app doesn't have Babel
  // installed in it. Instead, we try to load from our entry point's node_modules
  // directory (i.e. Grunt perhaps), and if it doesn't work, just keep going.
  attemptToPreload(names, prefix) {
    const fixupModule = exp => {
      // NB: Some plugins like transform-decorators-legacy, use import/export
      // semantics, and others don't
      if ('default' in exp) return exp['default'];
      return exp;
    };

    const preloadStrategies = [() => names.map(x => fixupModule(require.main.require(`babel-${ prefix }-${ x }`))), () => {
      let nodeModulesAboveUs = _path2.default.resolve(__dirname, '..', '..', '..');
      return names.map(x => fixupModule(require(_path2.default.join(nodeModulesAboveUs, `babel-${ prefix }-${ x }`))));
    }, () => names.map(x => fixupModule(require(`babel-${ prefix }-${ x }`)))];

    for (let strategy of preloadStrategies) {
      try {
        return strategy();
      } catch (e) {
        continue;
      }
    }

    return null;
  }

  compileSync(sourceCode, filePath, compilerContext) {
    babel = babel || require('babel-core');

    let opts = Object.assign({}, this.compilerOptions, {
      filename: filePath,
      ast: false,
      babelrc: false
    });

    if ('plugins' in opts) {
      let plugins = this.attemptToPreload(opts.plugins, 'plugin');
      if (plugins && plugins.length === opts.plugins.length) opts.plugins = plugins;
    }

    if ('presets' in opts) {
      let presets = this.attemptToPreload(opts.presets, 'preset');
      if (presets && presets.length === opts.presets.length) opts.presets = presets;
    }
    const output = babel.transform(sourceCode, opts);
    const sourceMaps = output.map ? JSON.stringify(output.map) : null;

    return {
      code: output.code,
      mimeType: 'application/javascript',
      sourceMaps
    };
  }

  getCompilerVersion() {
    return require('babel-core/package.json').version;
  }
}
exports.default = BabelCompiler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9qcy9iYWJlbC5qcyJdLCJuYW1lcyI6WyJtaW1lVHlwZXMiLCJiYWJlbCIsIkJhYmVsQ29tcGlsZXIiLCJjb25zdHJ1Y3RvciIsImdldElucHV0TWltZVR5cGVzIiwiYXR0ZW1wdFRvUHJlbG9hZCIsIm5hbWVzIiwicHJlZml4IiwiZml4dXBNb2R1bGUiLCJleHAiLCJwcmVsb2FkU3RyYXRlZ2llcyIsIm1hcCIsIngiLCJyZXF1aXJlIiwibWFpbiIsIm5vZGVNb2R1bGVzQWJvdmVVcyIsInJlc29sdmUiLCJfX2Rpcm5hbWUiLCJqb2luIiwic3RyYXRlZ3kiLCJlIiwiY29tcGlsZVN5bmMiLCJzb3VyY2VDb2RlIiwiZmlsZVBhdGgiLCJjb21waWxlckNvbnRleHQiLCJvcHRzIiwiT2JqZWN0IiwiYXNzaWduIiwiY29tcGlsZXJPcHRpb25zIiwiZmlsZW5hbWUiLCJhc3QiLCJiYWJlbHJjIiwicGx1Z2lucyIsImxlbmd0aCIsInByZXNldHMiLCJvdXRwdXQiLCJ0cmFuc2Zvcm0iLCJzb3VyY2VNYXBzIiwiSlNPTiIsInN0cmluZ2lmeSIsImNvZGUiLCJtaW1lVHlwZSIsImdldENvbXBpbGVyVmVyc2lvbiIsInZlcnNpb24iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFFQSxNQUFNQSxZQUFZLENBQUMsVUFBRCxFQUFhLHdCQUFiLENBQWxCO0FBQ0EsSUFBSUMsUUFBUSxJQUFaOztBQUVBOzs7QUFHZSxNQUFNQyxhQUFOLDBDQUErQztBQUM1REMsZ0JBQWM7QUFDWjtBQUNEOztBQUVELFNBQU9DLGlCQUFQLEdBQTJCO0FBQ3pCLFdBQU9KLFNBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBSyxtQkFBaUJDLEtBQWpCLEVBQXdCQyxNQUF4QixFQUFnQztBQUM5QixVQUFNQyxjQUFlQyxHQUFELElBQVM7QUFDM0I7QUFDQTtBQUNBLFVBQUksYUFBYUEsR0FBakIsRUFBc0IsT0FBT0EsSUFBSSxTQUFKLENBQVA7QUFDdEIsYUFBT0EsR0FBUDtBQUNELEtBTEQ7O0FBT0EsVUFBTUMsb0JBQW9CLENBQ3hCLE1BQU1KLE1BQU1LLEdBQU4sQ0FBV0MsQ0FBRCxJQUFPSixZQUFZSyxRQUFRQyxJQUFSLENBQWFELE9BQWIsQ0FBc0IsVUFBUU4sTUFBTyxNQUFHSyxDQUFFLEdBQTFDLENBQVosQ0FBakIsQ0FEa0IsRUFFeEIsTUFBTTtBQUNKLFVBQUlHLHFCQUFxQixlQUFLQyxPQUFMLENBQWFDLFNBQWIsRUFBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsSUFBcEMsQ0FBekI7QUFDQSxhQUFPWCxNQUFNSyxHQUFOLENBQVdDLENBQUQsSUFBT0osWUFBWUssUUFBUSxlQUFLSyxJQUFMLENBQVVILGtCQUFWLEVBQStCLFVBQVFSLE1BQU8sTUFBR0ssQ0FBRSxHQUFuRCxDQUFSLENBQVosQ0FBakIsQ0FBUDtBQUNELEtBTHVCLEVBTXhCLE1BQU1OLE1BQU1LLEdBQU4sQ0FBV0MsQ0FBRCxJQUFPSixZQUFZSyxRQUFTLFVBQVFOLE1BQU8sTUFBR0ssQ0FBRSxHQUE3QixDQUFaLENBQWpCLENBTmtCLENBQTFCOztBQVNBLFNBQUssSUFBSU8sUUFBVCxJQUFxQlQsaUJBQXJCLEVBQXdDO0FBQ3RDLFVBQUk7QUFDRixlQUFPUyxVQUFQO0FBQ0QsT0FGRCxDQUVFLE9BQU9DLENBQVAsRUFBVTtBQUNWO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPLElBQVA7QUFDRDs7QUFFREMsY0FBWUMsVUFBWixFQUF3QkMsUUFBeEIsRUFBa0NDLGVBQWxDLEVBQW1EO0FBQ2pEdkIsWUFBUUEsU0FBU1ksUUFBUSxZQUFSLENBQWpCOztBQUVBLFFBQUlZLE9BQU9DLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLEtBQUtDLGVBQXZCLEVBQXdDO0FBQ2pEQyxnQkFBVU4sUUFEdUM7QUFFakRPLFdBQUssS0FGNEM7QUFHakRDLGVBQVM7QUFId0MsS0FBeEMsQ0FBWDs7QUFNQSxRQUFJLGFBQWFOLElBQWpCLEVBQXVCO0FBQ3JCLFVBQUlPLFVBQVUsS0FBSzNCLGdCQUFMLENBQXNCb0IsS0FBS08sT0FBM0IsRUFBb0MsUUFBcEMsQ0FBZDtBQUNBLFVBQUlBLFdBQVdBLFFBQVFDLE1BQVIsS0FBbUJSLEtBQUtPLE9BQUwsQ0FBYUMsTUFBL0MsRUFBdURSLEtBQUtPLE9BQUwsR0FBZUEsT0FBZjtBQUN4RDs7QUFFRCxRQUFJLGFBQWFQLElBQWpCLEVBQXVCO0FBQ3JCLFVBQUlTLFVBQVUsS0FBSzdCLGdCQUFMLENBQXNCb0IsS0FBS1MsT0FBM0IsRUFBb0MsUUFBcEMsQ0FBZDtBQUNBLFVBQUlBLFdBQVdBLFFBQVFELE1BQVIsS0FBbUJSLEtBQUtTLE9BQUwsQ0FBYUQsTUFBL0MsRUFBdURSLEtBQUtTLE9BQUwsR0FBZUEsT0FBZjtBQUN4RDtBQUNELFVBQU1DLFNBQVNsQyxNQUFNbUMsU0FBTixDQUFnQmQsVUFBaEIsRUFBNEJHLElBQTVCLENBQWY7QUFDQSxVQUFNWSxhQUFhRixPQUFPeEIsR0FBUCxHQUFhMkIsS0FBS0MsU0FBTCxDQUFlSixPQUFPeEIsR0FBdEIsQ0FBYixHQUEwQyxJQUE3RDs7QUFFQSxXQUFPO0FBQ0w2QixZQUFNTCxPQUFPSyxJQURSO0FBRUxDLGdCQUFVLHdCQUZMO0FBR0xKO0FBSEssS0FBUDtBQUtEOztBQUVESyx1QkFBcUI7QUFDbkIsV0FBTzdCLFFBQVEseUJBQVIsRUFBbUM4QixPQUExQztBQUNEO0FBdkUyRDtrQkFBekN6QyxhIiwiZmlsZSI6ImJhYmVsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7U2ltcGxlQ29tcGlsZXJCYXNlfSBmcm9tICcuLi9jb21waWxlci1iYXNlJztcclxuXHJcbmNvbnN0IG1pbWVUeXBlcyA9IFsndGV4dC9qc3gnLCAnYXBwbGljYXRpb24vamF2YXNjcmlwdCddO1xyXG5sZXQgYmFiZWwgPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIEBhY2Nlc3MgcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFiZWxDb21waWxlciBleHRlbmRzIFNpbXBsZUNvbXBpbGVyQmFzZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldElucHV0TWltZVR5cGVzKCkge1xyXG4gICAgcmV0dXJuIG1pbWVUeXBlcztcclxuICB9XHJcblxyXG4gIC8vIE5COiBUaGlzIG1ldGhvZCBleGlzdHMgdG8gc3RvcCBCYWJlbCBmcm9tIHRyeWluZyB0byBsb2FkIHBsdWdpbnMgZnJvbSB0aGVcclxuICAvLyBhcHAncyBub2RlX21vZHVsZXMgZGlyZWN0b3J5LCB3aGljaCBpbiBhIHByb2R1Y3Rpb24gYXBwIGRvZXNuJ3QgaGF2ZSBCYWJlbFxyXG4gIC8vIGluc3RhbGxlZCBpbiBpdC4gSW5zdGVhZCwgd2UgdHJ5IHRvIGxvYWQgZnJvbSBvdXIgZW50cnkgcG9pbnQncyBub2RlX21vZHVsZXNcclxuICAvLyBkaXJlY3RvcnkgKGkuZS4gR3J1bnQgcGVyaGFwcyksIGFuZCBpZiBpdCBkb2Vzbid0IHdvcmssIGp1c3Qga2VlcCBnb2luZy5cclxuICBhdHRlbXB0VG9QcmVsb2FkKG5hbWVzLCBwcmVmaXgpIHtcclxuICAgIGNvbnN0IGZpeHVwTW9kdWxlID0gKGV4cCkgPT4ge1xyXG4gICAgICAvLyBOQjogU29tZSBwbHVnaW5zIGxpa2UgdHJhbnNmb3JtLWRlY29yYXRvcnMtbGVnYWN5LCB1c2UgaW1wb3J0L2V4cG9ydFxyXG4gICAgICAvLyBzZW1hbnRpY3MsIGFuZCBvdGhlcnMgZG9uJ3RcclxuICAgICAgaWYgKCdkZWZhdWx0JyBpbiBleHApIHJldHVybiBleHBbJ2RlZmF1bHQnXTtcclxuICAgICAgcmV0dXJuIGV4cDtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcHJlbG9hZFN0cmF0ZWdpZXMgPSBbXHJcbiAgICAgICgpID0+IG5hbWVzLm1hcCgoeCkgPT4gZml4dXBNb2R1bGUocmVxdWlyZS5tYWluLnJlcXVpcmUoYGJhYmVsLSR7cHJlZml4fS0ke3h9YCkpKSxcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIGxldCBub2RlTW9kdWxlc0Fib3ZlVXMgPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nKTtcclxuICAgICAgICByZXR1cm4gbmFtZXMubWFwKCh4KSA9PiBmaXh1cE1vZHVsZShyZXF1aXJlKHBhdGguam9pbihub2RlTW9kdWxlc0Fib3ZlVXMsIGBiYWJlbC0ke3ByZWZpeH0tJHt4fWApKSkpO1xyXG4gICAgICB9LFxyXG4gICAgICAoKSA9PiBuYW1lcy5tYXAoKHgpID0+IGZpeHVwTW9kdWxlKHJlcXVpcmUoYGJhYmVsLSR7cHJlZml4fS0ke3h9YCkpKVxyXG4gICAgXTtcclxuXHJcbiAgICBmb3IgKGxldCBzdHJhdGVneSBvZiBwcmVsb2FkU3RyYXRlZ2llcykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBzdHJhdGVneSgpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbXBpbGVTeW5jKHNvdXJjZUNvZGUsIGZpbGVQYXRoLCBjb21waWxlckNvbnRleHQpIHtcclxuICAgIGJhYmVsID0gYmFiZWwgfHwgcmVxdWlyZSgnYmFiZWwtY29yZScpO1xyXG5cclxuICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21waWxlck9wdGlvbnMsIHtcclxuICAgICAgZmlsZW5hbWU6IGZpbGVQYXRoLFxyXG4gICAgICBhc3Q6IGZhbHNlLFxyXG4gICAgICBiYWJlbHJjOiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCdwbHVnaW5zJyBpbiBvcHRzKSB7XHJcbiAgICAgIGxldCBwbHVnaW5zID0gdGhpcy5hdHRlbXB0VG9QcmVsb2FkKG9wdHMucGx1Z2lucywgJ3BsdWdpbicpO1xyXG4gICAgICBpZiAocGx1Z2lucyAmJiBwbHVnaW5zLmxlbmd0aCA9PT0gb3B0cy5wbHVnaW5zLmxlbmd0aCkgb3B0cy5wbHVnaW5zID0gcGx1Z2lucztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJ3ByZXNldHMnIGluIG9wdHMpIHtcclxuICAgICAgbGV0IHByZXNldHMgPSB0aGlzLmF0dGVtcHRUb1ByZWxvYWQob3B0cy5wcmVzZXRzLCAncHJlc2V0Jyk7XHJcbiAgICAgIGlmIChwcmVzZXRzICYmIHByZXNldHMubGVuZ3RoID09PSBvcHRzLnByZXNldHMubGVuZ3RoKSBvcHRzLnByZXNldHMgPSBwcmVzZXRzO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3V0cHV0ID0gYmFiZWwudHJhbnNmb3JtKHNvdXJjZUNvZGUsIG9wdHMpO1xyXG4gICAgY29uc3Qgc291cmNlTWFwcyA9IG91dHB1dC5tYXAgPyBKU09OLnN0cmluZ2lmeShvdXRwdXQubWFwKSA6IG51bGw7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29kZTogb3V0cHV0LmNvZGUsXHJcbiAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXHJcbiAgICAgIHNvdXJjZU1hcHNcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBnZXRDb21waWxlclZlcnNpb24oKSB7XHJcbiAgICByZXR1cm4gcmVxdWlyZSgnYmFiZWwtY29yZS9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xyXG4gIH1cclxufVxyXG4iXX0=